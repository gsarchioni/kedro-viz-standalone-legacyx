"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.useGeneratePathnameForExperimentTracking = exports.useGeneratePathname = void 0;
var _react = require("react");
var _reactRouterDom = require("react-router-dom");
var _config = require("../../config");
var _utils = require("../../utils");
const getCurrentActivePipeline = () => {
  var _JSON$parse;
  const localStorage = window.localStorage.getItem(_config.localStorageName);
  return (_JSON$parse = JSON.parse(localStorage)) === null || _JSON$parse === void 0 || (_JSON$parse = _JSON$parse.pipeline) === null || _JSON$parse === void 0 ? void 0 : _JSON$parse.active;
};

/**
 * Retains default query parameters and removes all others from the given searchParams object.
 * @param {URLSearchParams} searchParams - The searchParams object to modify.
 */
const retainDefaultQueryParams = searchParams => {
  const searchParamsEntries = [...searchParams.keys()];
  for (const key of searchParamsEntries) {
    if (!_config.defaultQueryParams.includes(key)) {
      searchParams.delete(key);
    }
  }
};

/**
 * To generate different pathnames based on each action
 * E.g.: click on a node, or focus on a modular pipeline
 * or to reset the pathname to the main page
 */
const useGeneratePathname = () => {
  const history = (0, _reactRouterDom.useHistory)();

  /**
   * Updates the URL with search parameters based on the provided update function.
   * @param {Function} updateFunction - The function that updates the search parameters.
   */
  const updateURLWithSearchParams = (0, _react.useCallback)(updateFunction => {
    const searchParams = new URLSearchParams(history.location.search);
    updateFunction(searchParams);
    const url = decodeURIComponent(history.location.pathname + '?' + searchParams.toString());
    history.push(url);
  }, [history]);
  const toFlowchartPage = (0, _react.useCallback)(() => {
    updateURLWithSearchParams(retainDefaultQueryParams);
  }, [updateURLWithSearchParams]);
  const toSelectedPipeline = (0, _react.useCallback)(pipelineValue => {
    updateURLWithSearchParams(searchParams => {
      retainDefaultQueryParams(searchParams);

      // Get the value from param if it exists first
      // before checking from localStorage
      const activePipeline = pipelineValue ? pipelineValue : getCurrentActivePipeline();
      searchParams.set(_config.params.pipeline, activePipeline);
    });
  }, [updateURLWithSearchParams]);
  const toSelectedNode = (0, _react.useCallback)(item => {
    updateURLWithSearchParams(searchParams => {
      searchParams.set(_config.params.selected, item.id);
    });
  }, [updateURLWithSearchParams]);
  const toFocusedModularPipeline = (0, _react.useCallback)(item => {
    updateURLWithSearchParams(searchParams => {
      searchParams.set(_config.params.focused, item.id);
    });
  }, [updateURLWithSearchParams]);
  const toSetQueryParam = (0, _react.useCallback)((param, value) => {
    updateURLWithSearchParams(searchParams => {
      if (Array.isArray(value) && value.length === 0) {
        searchParams.delete(param);
      } else {
        searchParams.set(param, value);
      }
    });
  }, [updateURLWithSearchParams]);
  const toUpdateUrlParamsOnResetFilter = (0, _react.useCallback)(() => {
    updateURLWithSearchParams(searchParams => {
      searchParams.delete(_config.params.tags);
      searchParams.set(_config.params.types, "".concat(_config.NODE_TYPES.task.name, ",").concat(_config.NODE_TYPES.data.name));
    });
  }, [updateURLWithSearchParams]);
  const toUpdateUrlParamsOnFilter = (item, paramName, existingValues) => {
    const mapItemId = (0, _utils.mapNodeType)(item.id);
    if (item.checked) {
      existingValues.delete(mapItemId);
    } else {
      existingValues.add(mapItemId);
    }
    toSetQueryParam(paramName, Array.from(existingValues));
  };
  return {
    toSelectedPipeline,
    toFlowchartPage,
    toSelectedNode,
    toFocusedModularPipeline,
    toSetQueryParam,
    toUpdateUrlParamsOnResetFilter,
    toUpdateUrlParamsOnFilter
  };
};
exports.useGeneratePathname = useGeneratePathname;
const useGeneratePathnameForExperimentTracking = () => {
  const history = (0, _reactRouterDom.useHistory)();
  const toExperimentTrackingPath = (0, _react.useCallback)(() => {
    const url = (0, _reactRouterDom.generatePath)(_config.routes.experimentTracking.main);
    history.push(url);
  }, [history]);
  const toMetricsViewPath = (0, _react.useCallback)(() => {
    const url = (0, _reactRouterDom.generatePath)(_config.routes.experimentTracking.selectedView, {
      view: 'Metrics'
    });
    history.push(url);
  }, [history]);
  const toSelectedRunsPath = (0, _react.useCallback)((ids, view, isComparison) => {
    const url = (0, _reactRouterDom.generatePath)(_config.routes.experimentTracking.selectedRuns, {
      ids: ids.length === 1 ? ids[0] : ids.toString(),
      view,
      isComparison
    });
    history.push(url);
  }, [history]);
  return {
    toExperimentTrackingPath,
    toMetricsViewPath,
    toSelectedRunsPath
  };
};
exports.useGeneratePathnameForExperimentTracking = useGeneratePathnameForExperimentTracking;