"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.changed = exports.arrayToObject = void 0;
exports.deployViz = deployViz;
exports.fetchPackageCompatibilities = fetchPackageCompatibilities;
exports.unique = exports.stripNamespace = exports.sanitizedPathname = exports.replaceMatches = exports.replaceAngleBracketMatches = exports.prettifyName = exports.prettifyModularPipelineNames = exports.mapNodeTypes = exports.mapNodeType = exports.isValidBoolean = exports.isRunningLocally = exports.getUrl = exports.formatNumberWithCommas = exports.formatFileSize = void 0;
//--- Useful JS utility functions ---//
const pathRoot = './api';

/**
 * Loop through an array and output to an object
 * @param {Array} array
 * @param {Function} callback
 */
const arrayToObject = (array, callback) => {
  const newObject = {};
  array.forEach(key => {
    newObject[key] = callback(key);
  });
  return newObject;
};

/**
 * Determine the endpoint URL for loading different data types
 * @param {String} type Data type
 * @param {String=} id Endpoint identifier e.g. pipeline ID
 */
exports.arrayToObject = arrayToObject;
const getUrl = (type, id) => {
  switch (type) {
    case 'main':
      return [pathRoot, 'main'].join('/');
    case 'pipeline':
      if (!id) {
        throw new Error('No pipeline ID provided');
      }
      return [pathRoot, 'pipelines', id].join('/');
    case 'nodes':
      if (!id) {
        throw new Error('No node ID provided');
      }
      return [pathRoot, 'nodes', id].join('/');
    default:
      throw new Error('Unknown URL type');
  }
};

/**
 * Filter duplicate values from an array
 * @param {any} d Datum
 * @param {Number} i Index
 * @param {Array} arr The array to remove duplicate values from
 */
exports.getUrl = getUrl;
const unique = (d, i, arr) => arr.indexOf(d) === i;

/**
 * Returns true if any of the given props are different between given objects.
 * Only shallow changes are detected.
 * @param {Array} props The prop names to check
 * @param {Object} objectA The first object
 * @param {Object} objectB The second object
 * @returns {Boolean} True if any prop changed else false
 */
exports.unique = unique;
const changed = (props, objectA, objectB) => {
  return objectA && objectB && props.some(prop => objectA[prop] !== objectB[prop]);
};

/**
 * Replace any parts of a string that match the keys in the toReplace object
 * @param {String} str The string to check
 * @param {Object} toReplace The object of strings to replace and their replacements
 * @returns {String} The string with or without replaced values
 */
exports.changed = changed;
const replaceMatches = (str, toReplace) => {
  if ((str === null || str === void 0 ? void 0 : str.length) > 0) {
    const regex = new RegExp(Object.keys(toReplace).join('|'), 'gi');
    return str.replace(regex, matched => {
      return toReplace[matched];
    });
  } else {
    return str;
  }
};

/**
 * Replace any parts of a string that match the '<' & '>' except '<b>' & '</b>'
 * @param {String} str The string to check
 * @returns {String} The string with or without replaced values
 */
exports.replaceMatches = replaceMatches;
const replaceAngleBracketMatches = str => {
  if ((str === null || str === void 0 ? void 0 : str.length) > 0) {
    // Handling string like '<lambda>' or '<partial>' in 3 steps
    // 1. replacing all '<b>' & '</b>' with unique '@$1$@' & '@$2$@' respectively
    // 2. replacing all '<' & '>' with '&lt;' & '&gt;' respectively
    // 3. replacing back all '@$1$@' & '@$2$@' with <b> & </b> respectively
    const strWithoutBTag = str.replaceAll('<b>', '@$1$@').replaceAll('</b>', '@$2$@');
    const replacedWithAngleBracket = strWithoutBTag.replaceAll('<', '&lt;').replaceAll('>', '&gt;');
    const result = replacedWithAngleBracket.replaceAll('@$1$@', '<b>').replaceAll('@$2$@', '</b>');
    return result;
  } else {
    return str;
  }
};

/**
 * Removes any parts of a string that match the regular expression
 * @param {String} str The string to check
 * @returns {String} The string with or without removed values
 */
exports.replaceAngleBracketMatches = replaceAngleBracketMatches;
const stripNamespace = str => {
  const pattern = new RegExp('[A-Za-z0-9-_]+\\.', 'g');
  return str.replace(pattern, '');
};

/**
 * Replaces any parts of a string that match the pattern with the target pattern and capitalizes each word in the string separated by a space
 * @param {String} str The string to check
 * @returns {String} The string with or without replaced values
 */
exports.stripNamespace = stripNamespace;
const prettifyName = str => {
  const replacedString = str.replace(/-/g, ' ').replace(/_/g, ' ').replace(/:/g, ': ').trim();
  return replacedString.replace(/(^|\s)\S/g, match => match.toUpperCase());
};

/**
 * Prettifies name property of the nested object in a modularPipeline
 * @param {Object} modularPipelines The object whose nested object property needs to be prettified
 * @returns {Object} The object with or without prettified name inside the nested object
 */
exports.prettifyName = prettifyName;
const prettifyModularPipelineNames = modularPipelines => {
  for (const key in modularPipelines) {
    if (modularPipelines.hasOwnProperty(key)) {
      const modularPipeline = modularPipelines[key];
      if (modularPipeline.hasOwnProperty('name')) {
        modularPipelines[key] = {
          ...modularPipeline,
          name: prettifyName(modularPipeline['name'])
        };
      }
    }
  }
  return modularPipelines;
};

/**
 * Formats file size for the dataset metadata stats
 * @param {Number} fileSizeInBytes The file size in bytes
 * @returns {String} The formatted file size as e.g. "1.1KB"
 */
exports.prettifyModularPipelineNames = prettifyModularPipelineNames;
const formatFileSize = fileSizeInBytes => {
  // This is to convert bytes to KB or MB.
  const conversionUnit = 1000;
  if (!fileSizeInBytes) {
    // dataset not configured
    return 'N/A';
  } else if (fileSizeInBytes < conversionUnit) {
    // Less than 1 KB
    return "".concat(fileSizeInBytes, " bytes");
  } else if (fileSizeInBytes < conversionUnit * conversionUnit) {
    //  Less than 1 MB
    const sizeInKB = fileSizeInBytes / conversionUnit;
    return "".concat(sizeInKB.toFixed(1), "KB");
  } else {
    const sizeInMB = fileSizeInBytes / (conversionUnit * conversionUnit);
    return "".concat(sizeInMB.toFixed(1), "MB");
  }
};

/**
 * Formats a number to a comma separated string
 * @param {Number} number The number to be formatted
 * @returns {String} The formatted number e.g. 2500 -> 2,500
 */
exports.formatFileSize = formatFileSize;
const formatNumberWithCommas = number => {
  return number.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
};

/**
 * Test if Kedro-Viz is running on our known local ports.
 * @returns {Boolean} True if the app is running locally.
 */
exports.formatNumberWithCommas = formatNumberWithCommas;
const isRunningLocally = () => {
  const hosts = ['localhost', '127.0.0.1', 'demo.kedro.org', 'gitpod'];
  const itemFound = hosts.some(host => window.location.hostname.includes(host));
  return itemFound;
};

/**
 * Sanitized pathname with experiment-tracking string and check if path containing trailing slash
 * @returns {string} Sanitized pathname
 */
exports.isRunningLocally = isRunningLocally;
const sanitizedPathname = () => {
  const {
    pathname
  } = window.location;
  const sanitizedPathname = replaceMatches(pathname, {
    'experiment-tracking': ''
  });
  const pathnameWithTrailingSlash = sanitizedPathname.endsWith('/') ? sanitizedPathname : "".concat(sanitizedPathname, "/"); // the `pathname` will have a trailing slash if it didn't initially

  return pathnameWithTrailingSlash;
};

/**
 * Fetches package compatibilities from the server.
 * @returns {Promise<Object>} A promise that resolves to the fetched package compatibilities.
 */
exports.sanitizedPathname = sanitizedPathname;
async function fetchPackageCompatibilities() {
  const request = await fetch('/api/package-compatibilities', {
    headers: {
      'Content-Type': 'application/json',
      Accept: 'application/json'
    }
  });
  return request;
}
async function deployViz(inputValues) {
  const request = await fetch('/api/deploy', {
    headers: {
      'Content-Type': 'application/json'
    },
    method: 'POST',
    body: JSON.stringify(inputValues)
  });
  return request;
}
const nodeTypeMapObj = {
  nodes: 'task',
  task: 'nodes',
  datasets: 'data',
  data: 'datasets'
};
/**
 * Mapping task to node and vice versa to keep UI label & the URL consistent
 */
const mapNodeType = nodeType => nodeTypeMapObj[nodeType] || nodeType;
exports.mapNodeType = mapNodeType;
const mapNodeTypes = nodeTypes => {
  return nodeTypes.replace(/task|data/g, matched => mapNodeType(matched));
};

/**
 * Test if the passed string value is valid boolean
 * @param {String} inputString
 * @returns {Boolean} true if the inputString is a valid boolean
 */
exports.mapNodeTypes = mapNodeTypes;
const isValidBoolean = inputString => {
  return /^(true|false)$/i.test(inputString);
};
exports.isValidBoolean = isValidBoolean;