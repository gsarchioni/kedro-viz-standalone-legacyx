"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapStateToProps = exports.mapDispatchToProps = exports.default = exports.FlowChartWrapper = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactRouterDom = require("react-router-dom");
var _reactRedux = require("react-redux");
var _classnames = _interopRequireDefault(require("classnames"));
var _loading = require("../../selectors/loading");
var _nodes = require("../../selectors/nodes");
var _metadata = require("../../selectors/metadata");
var _modularPipelines = require("../../actions/modular-pipelines");
var _actions = require("../../actions");
var _nodes2 = require("../../actions/nodes");
var _pipelines = require("../../actions/pipelines");
var _exportModal = _interopRequireDefault(require("../export-modal"));
var _flowchart = _interopRequireDefault(require("../flowchart"));
var _pipelineWarning = _interopRequireDefault(require("../pipeline-warning"));
var _loading2 = _interopRequireDefault(require("../icons/loading"));
var _metadata2 = _interopRequireDefault(require("../metadata"));
var _metadataModal = _interopRequireDefault(require("../metadata-modal"));
var _shareableUrlMetadata = _interopRequireDefault(require("../shareable-url-modal/shareable-url-metadata"));
var _sidebar = _interopRequireDefault(require("../sidebar"));
var _button = _interopRequireDefault(require("../ui/button"));
var _circleProgressBar = _interopRequireDefault(require("../ui/circle-progress-bar"));
var _helpers = require("../../store/helpers");
var _config = require("../../config");
var _matchPath = require("../../utils/match-path");
var _objectUtils = require("../../utils/object-utils");
var _utils = require("../../utils");
var _useGeneratePathname = require("../../utils/hooks/use-generate-pathname");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Main flowchart container. Handles showing/hiding the sidebar nav for flowchart view,
 * the rendering of the flowchart, as well as the display of all related modals.
 */
const FlowChartWrapper = _ref => {
  let {
    fullNodeNames,
    displaySidebar,
    graph,
    loading,
    metadataVisible,
    modularPipelinesTree,
    nodes,
    onToggleFocusMode,
    onToggleModularPipelineActive,
    onToggleModularPipelineExpanded,
    onToggleNodeSelected,
    onUpdateActivePipeline,
    pipelines,
    sidebarVisible,
    activePipeline,
    tag,
    nodeType,
    expandAllPipelines,
    displayMetadataPanel,
    displayExportBtn
  } = _ref;
  const history = (0, _reactRouterDom.useHistory)();
  const {
    pathname,
    search
  } = (0, _reactRouterDom.useLocation)();
  const searchParams = new URLSearchParams(search);
  const {
    toSetQueryParam
  } = (0, _useGeneratePathname.useGeneratePathname)();
  const [errorMessage, setErrorMessage] = (0, _react.useState)({});
  const [isInvalidUrl, setIsInvalidUrl] = (0, _react.useState)(false);
  const [usedNavigationBtn, setUsedNavigationBtn] = (0, _react.useState)(false);
  const [counter, setCounter] = (0, _react.useState)(60);
  const [goBackToExperimentTracking, setGoBackToExperimentTracking] = (0, _react.useState)(false);
  const graphRef = (0, _react.useRef)(null);
  const {
    matchedFlowchartMainPage,
    matchedSelectedPipeline,
    matchedSelectedNodeId,
    matchedSelectedNodeName,
    matchedFocusedNode
  } = (0, _matchPath.findMatchedPath)(pathname, search);

  /**
   * On initial load & when user switch active pipeline,
   * sets the query params from local storage based on NodeType, tag, expandAllPipelines and active pipeline.
   * @param {string} activePipeline - The active pipeline.
   */
  const setParamsFromLocalStorage = activePipeline => {
    const localStorageParams = (0, _helpers.loadLocalStorage)(_config.localStorageName);
    if (localStorageParams) {
      const paramActions = {
        pipeline: value => {
          if (activePipeline) {
            toSetQueryParam(_config.params.pipeline, value.active || activePipeline);
          }
        },
        tag: value => {
          const enabledKeys = (0, _objectUtils.getKeysByValue)(value.enabled, true);
          enabledKeys && toSetQueryParam(_config.params.tags, enabledKeys);
        },
        nodeType: value => {
          const disabledKeys = (0, _objectUtils.getKeysByValue)(value.disabled, false);
          // Replace task with node to keep UI label & the URL consistent
          const mappedDisabledNodes = (0, _utils.mapNodeTypes)(disabledKeys);
          disabledKeys && toSetQueryParam(_config.params.types, mappedDisabledNodes);
        },
        expandAllPipelines: value => toSetQueryParam(_config.params.expandAll, value)
      };
      for (const [key, value] of Object.entries(localStorageParams)) {
        if (paramActions[key]) {
          paramActions[key](value);
        }
      }
    }
  };
  (0, _react.useEffect)(() => {
    setParamsFromLocalStorage(activePipeline);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [activePipeline, tag, nodeType, expandAllPipelines]);
  const resetErrorMessage = () => {
    setErrorMessage({});
    setIsInvalidUrl(false);
  };
  const checkIfPipelineExists = () => {
    const pipelineId = searchParams.get(_config.params.pipeline);
    const foundPipeline = pipelines.find(id => id === pipelineId);
    if (!foundPipeline) {
      setErrorMessage(_config.errorMessages.pipeline);
      setIsInvalidUrl(true);
    }
  };
  const redirectSelectedPipeline = () => {
    const pipelineId = searchParams.get(_config.params.pipeline);
    const foundPipeline = pipelines.find(id => id === pipelineId);
    if (foundPipeline) {
      onUpdateActivePipeline(foundPipeline);
      onToggleNodeSelected(null);
      onToggleFocusMode(null);
    } else {
      setErrorMessage(_config.errorMessages.pipeline);
      setIsInvalidUrl(true);
    }
  };
  const redirectToSelectedNode = () => {
    const node = searchParams.get(_config.params.selected) || searchParams.get(_config.params.selectedName);
    const nodeId = (0, _objectUtils.getKeyByValue)(fullNodeNames, node) || Object.keys(nodes).find(nodeId => nodeId === node);
    if (nodeId) {
      const modularPipeline = nodes[nodeId];
      const hasModularPipeline = (modularPipeline === null || modularPipeline === void 0 ? void 0 : modularPipeline.length) > 0;
      const isParameterType = graph.nodes && graph.nodes.find(node => node.id === nodeId && node.type === 'parameters');
      if (hasModularPipeline && !isParameterType) {
        onToggleModularPipelineExpanded(modularPipeline);
      }
      onToggleNodeSelected(nodeId);
      if (isInvalidUrl) {
        resetErrorMessage();
      }
    } else {
      setErrorMessage(_config.errorMessages.node);
      setIsInvalidUrl(true);
    }
    checkIfPipelineExists();
  };
  const redirectToFocusedNode = () => {
    const focusedId = searchParams.get(_config.params.focused);
    const foundModularPipeline = modularPipelinesTree[focusedId];
    if (foundModularPipeline) {
      onToggleModularPipelineActive(focusedId, true);
      onToggleFocusMode(foundModularPipeline.data);
      if (isInvalidUrl) {
        resetErrorMessage();
      }
    } else {
      setErrorMessage(_config.errorMessages.modularPipeline);
      setIsInvalidUrl(true);
    }
    checkIfPipelineExists();
  };
  const handlePopState = (0, _react.useCallback)(() => {
    setUsedNavigationBtn(usedNavigationBtn => !usedNavigationBtn);
  }, []);
  (0, _react.useEffect)(() => {
    window.addEventListener('popstate', handlePopState);
    return () => {
      window.removeEventListener('popstate', handlePopState);
    };
  }, [handlePopState]);
  (0, _react.useEffect)(() => {
    setGoBackToExperimentTracking((0, _helpers.loadLocalStorage)(_config.localStorageFlowchartLink));
  }, []);

  /**
   * To handle redirecting to a different location via the URL (e.g. selectedNode,
   * focusNode, etc.) we only need to call the matchPath actions when:
   * 1. graphRef.current is null, meaning the page has just loaded
   * 2. or when the user navigates using the back and forward buttons
   * 3. or when invalidUrl is true, meaning the user entered something wrong in
   * the URL and we should allow them to reset by clicking on a different node.
   */
  (0, _react.useEffect)(() => {
    const isGraphEmpty = Object.keys(graph).length === 0;
    if ((graphRef.current === null || usedNavigationBtn || isInvalidUrl) && !isGraphEmpty) {
      if (matchedFlowchartMainPage) {
        onToggleNodeSelected(null);
        onToggleFocusMode(null);
        resetErrorMessage();
      }
      if (matchedSelectedPipeline()) {
        // Redirecting to a different pipeline is also handled at `preparePipelineState`
        // to ensure the data is ready before being passed to here
        redirectSelectedPipeline();
      }
      if (matchedSelectedNodeName() || matchedSelectedNodeId()) {
        redirectToSelectedNode();
      }
      if (matchedFocusedNode()) {
        redirectToFocusedNode();
      }

      // Once all the matchPath checks are finished
      // ensure the local states are reset
      graphRef.current = graph;
      setUsedNavigationBtn(false);
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [graph, usedNavigationBtn, isInvalidUrl]);
  const resetLinkingToFlowchartLocalStorage = (0, _react.useCallback)(() => {
    (0, _helpers.saveLocalStorage)(_config.localStorageFlowchartLink, _config.linkToFlowchartInitialVal);
    setGoBackToExperimentTracking(_config.linkToFlowchartInitialVal);
  }, []);
  (0, _react.useEffect)(() => {
    if (goBackToExperimentTracking !== null && goBackToExperimentTracking !== void 0 && goBackToExperimentTracking.showGoBackBtn) {
      const timer = counter > 0 && setInterval(() => setCounter(counter - 1), 1000);
      if (counter === 0) {
        resetLinkingToFlowchartLocalStorage();
      }
      return () => clearInterval(timer);
    }
  }, [counter, goBackToExperimentTracking === null || goBackToExperimentTracking === void 0 ? void 0 : goBackToExperimentTracking.showGoBackBtn, resetLinkingToFlowchartLocalStorage]);
  const onGoBackToExperimentTrackingHandler = () => {
    const url = goBackToExperimentTracking.fromURL;
    history.push(url);
    resetLinkingToFlowchartLocalStorage();
  };
  if (isInvalidUrl) {
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "kedro-pipeline"
    }, displaySidebar && /*#__PURE__*/_react.default.createElement(_sidebar.default, null), displayMetadataPanel && /*#__PURE__*/_react.default.createElement(_metadata2.default, null), /*#__PURE__*/_react.default.createElement(_pipelineWarning.default, {
      errorMessage: errorMessage,
      invalidUrl: isInvalidUrl,
      onResetClick: () => setIsInvalidUrl(false)
    }));
  } else {
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "kedro-pipeline"
    }, displaySidebar && /*#__PURE__*/_react.default.createElement(_sidebar.default, null), displayMetadataPanel && /*#__PURE__*/_react.default.createElement(_metadata2.default, null), /*#__PURE__*/_react.default.createElement("div", {
      className: "pipeline-wrapper"
    }, /*#__PURE__*/_react.default.createElement(_pipelineWarning.default, null), /*#__PURE__*/_react.default.createElement(_flowchart.default, null), /*#__PURE__*/_react.default.createElement("div", {
      className: (0, _classnames.default)('pipeline-wrapper__go-back-btn', {
        'pipeline-wrapper__go-back-btn--show': goBackToExperimentTracking === null || goBackToExperimentTracking === void 0 ? void 0 : goBackToExperimentTracking.showGoBackBtn,
        'pipeline-wrapper__go-back-btn--show-sidebar-visible': sidebarVisible,
        'pipeline-wrapper__go-back-btn--show-metadata-visible': metadataVisible
      })
    }, /*#__PURE__*/_react.default.createElement(_button.default, {
      onClick: onGoBackToExperimentTrackingHandler
    }, /*#__PURE__*/_react.default.createElement(_circleProgressBar.default, null, counter), "Return to Experiment Tracking")), /*#__PURE__*/_react.default.createElement("div", {
      className: (0, _classnames.default)('pipeline-wrapper__loading', {
        'pipeline-wrapper__loading--sidebar-visible': sidebarVisible
      })
    }, /*#__PURE__*/_react.default.createElement(_loading2.default, {
      visible: loading
    })), (0, _utils.isRunningLocally)() ? null : /*#__PURE__*/_react.default.createElement(_shareableUrlMetadata.default, null)), displayExportBtn && /*#__PURE__*/_react.default.createElement(_exportModal.default, null), /*#__PURE__*/_react.default.createElement(_metadataModal.default, null));
  }
};
exports.FlowChartWrapper = FlowChartWrapper;
const mapStateToProps = state => ({
  fullNodeNames: (0, _nodes.getNodeFullName)(state),
  displaySidebar: state.display.sidebar,
  graph: state.graph,
  loading: (0, _loading.isLoading)(state),
  metadataVisible: (0, _metadata.getVisibleMetaSidebar)(state),
  modularPipelinesTree: (0, _nodes.getModularPipelinesTree)(state),
  nodes: state.node.modularPipelines,
  pipelines: state.pipeline.ids,
  activePipeline: state.pipeline.active,
  sidebarVisible: state.visible.sidebar,
  tag: state.tag.enabled,
  nodeType: state.nodeType.disabled,
  expandAllPipelines: state.expandAllPipelines,
  displayMetadataPanel: state.display.metadataPanel,
  displayExportBtn: state.display.exportBtn
});
exports.mapStateToProps = mapStateToProps;
const mapDispatchToProps = dispatch => ({
  onToggleFocusMode: modularPipeline => {
    dispatch((0, _actions.toggleFocusMode)(modularPipeline));
  },
  onToggleNodeSelected: nodeID => {
    dispatch((0, _nodes2.loadNodeData)(nodeID));
  },
  onToggleModularPipelineActive: (modularPipelineIDs, active) => {
    dispatch((0, _modularPipelines.toggleModularPipelineActive)(modularPipelineIDs, active));
  },
  onToggleModularPipelineExpanded: expanded => {
    dispatch((0, _modularPipelines.toggleModularPipelinesExpanded)(expanded));
  },
  onUpdateActivePipeline: pipelineId => {
    dispatch((0, _pipelines.loadPipelineData)(pipelineId));
  }
});
exports.mapDispatchToProps = mapDispatchToProps;
var _default = exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(FlowChartWrapper);