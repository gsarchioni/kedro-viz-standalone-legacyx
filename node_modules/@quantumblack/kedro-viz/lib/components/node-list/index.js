"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapStateToProps = exports.mapDispatchToProps = exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactRedux = require("react-redux");
var _debounce = _interopRequireDefault(require("lodash/debounce"));
var _nodeList = _interopRequireDefault(require("./node-list"));
var _nodeListItems = require("./node-list-items");
var _nodeTypes = require("../../selectors/node-types");
var _tags = require("../../selectors/tags");
var _modularPipelines = require("../../selectors/modular-pipelines");
var _nodes = require("../../selectors/nodes");
var _tags2 = require("../../actions/tags");
var _nodeType = require("../../actions/node-type");
var _actions = require("../../actions");
var _modularPipelines2 = require("../../actions/modular-pipelines");
var _nodes2 = require("../../actions/nodes");
var _useGeneratePathname = require("../../utils/hooks/use-generate-pathname");
var _config = require("../../config");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Provides data from the store to populate a NodeList component.
 * Also handles user interaction and dispatches updates back to the store.
 */
const NodeListProvider = _ref => {
  let {
    faded,
    nodes,
    nodeSelected,
    tags,
    tagNodeCounts,
    nodeTypes,
    onToggleNodesDisabled,
    onToggleNodeSelected,
    onToggleNodeActive,
    onToggleParametersActive,
    onToggleTagActive,
    onToggleTagFilter,
    onToggleModularPipelineActive,
    onToggleModularPipelineDisabled,
    onToggleModularPipelineExpanded,
    onToggleTypeDisabled,
    onToggleFocusMode,
    modularPipelinesTree,
    focusMode,
    disabledModularPipeline,
    inputOutputDataNodes
  } = _ref;
  const [searchValue, updateSearchValue] = (0, _react.useState)('');
  const [isResetFilterActive, setIsResetFilterActive] = (0, _react.useState)(false);
  const {
    toSelectedPipeline,
    toSelectedNode,
    toFocusedModularPipeline,
    toUpdateUrlParamsOnResetFilter,
    toUpdateUrlParamsOnFilter,
    toSetQueryParam
  } = (0, _useGeneratePathname.useGeneratePathname)();
  const items = (0, _nodeListItems.getFilteredItems)({
    nodes,
    tags,
    nodeTypes,
    tagNodeCounts,
    nodeSelected,
    searchValue,
    focusMode,
    inputOutputDataNodes
  });
  const modularPipelinesSearchResult = searchValue ? (0, _modularPipelines.getModularPipelinesSearchResult)(modularPipelinesTree, searchValue) : null;
  const groups = (0, _nodeListItems.getGroups)({
    items
  });
  const onItemClick = item => {
    if ((0, _nodeListItems.isGroupType)(item.type)) {
      onGroupItemChange(item, item.checked);
    } else if ((0, _nodeTypes.isModularPipelineType)(item.type)) {
      onToggleNodeSelected(null);
    } else {
      if (item.faded || item.selected) {
        onToggleNodeSelected(null);
        toSelectedPipeline();
      } else {
        onToggleNodeSelected(item.id);
        toSelectedNode(item);
      }
    }
  };

  // To get existing values from URL query parameters
  const getExistingValuesFromUrlQueryParams = (paramName, searchParams) => {
    const paramValues = searchParams.get(paramName);
    return new Set(paramValues ? paramValues.split(',') : []);
  };
  const handleUrlParamsUpdateOnFilter = item => {
    const searchParams = new URLSearchParams(window.location.search);
    const paramName = (0, _nodeListItems.isElementType)(item.type) ? _config.params.types : _config.params.tags;
    const existingValues = getExistingValuesFromUrlQueryParams(paramName, searchParams);
    toUpdateUrlParamsOnFilter(item, paramName, existingValues);
  };

  // To update URL query parameters when a filter group is clicked
  const handleUrlParamsUpdateOnGroupFilter = (groupType, groupItems, groupItemsDisabled) => {
    if (groupItemsDisabled) {
      // If all items in group are disabled
      groupItems.forEach(item => {
        handleUrlParamsUpdateOnFilter(item);
      });
    } else {
      // If some items in group are enabled
      const paramName = (0, _nodeListItems.isElementType)(groupType) ? _config.params.types : _config.params.tags;
      toSetQueryParam(paramName, []);
    }
  };
  const onItemChange = (item, checked, clickedIconType) => {
    if ((0, _nodeListItems.isGroupType)(item.type) || (0, _nodeTypes.isModularPipelineType)(item.type)) {
      onGroupItemChange(item, checked);

      // Update URL query parameters when a filter item is clicked
      if (!clickedIconType) {
        handleUrlParamsUpdateOnFilter(item);
      }
      if ((0, _nodeTypes.isModularPipelineType)(item.type)) {
        if (clickedIconType === 'focus') {
          if (focusMode === null) {
            onToggleFocusMode(item);
            toFocusedModularPipeline(item);
            if (disabledModularPipeline[item.id]) {
              onToggleModularPipelineDisabled([item.id], checked);
            }
          } else {
            onToggleFocusMode(null);
            toSelectedPipeline();
          }
        } else {
          onToggleModularPipelineDisabled([item.id], checked);
          onToggleModularPipelineActive([item.id], false);
        }
      }
    } else {
      if (checked) {
        onToggleNodeActive(null);
      }
      onToggleNodesDisabled([item.id], checked);
    }
  };
  const onItemMouseEnter = item => {
    if ((0, _nodeListItems.isTagType)(item.type)) {
      onToggleTagActive(item.id, true);
    } else if ((0, _nodeTypes.isModularPipelineType)(item.type)) {
      onToggleModularPipelineActive(item.id, true);
    } else if ((0, _nodeListItems.isElementType)(item.type) && item.id === 'parameters') {
      // Show parameters highlight when mouse enter parameters filter item
      onToggleParametersActive(true);
    } else if (item.visible) {
      onToggleNodeActive(item.id);
    }
  };
  const onItemMouseLeave = item => {
    if ((0, _nodeListItems.isTagType)(item.type)) {
      onToggleTagActive(item.id, false);
    } else if ((0, _nodeTypes.isModularPipelineType)(item.type)) {
      onToggleModularPipelineActive(item.id, false);
    } else if ((0, _nodeListItems.isElementType)(item.type) && item.id === 'parameters') {
      // Hide parameters highlight when mouse leave parameters filter item
      onToggleParametersActive(false);
    } else if (item.visible) {
      onToggleNodeActive(null);
    }
  };
  const onGroupToggleChanged = groupType => {
    // Enable all items in group if none enabled, otherwise disable all of them
    const groupItems = items[groupType] || [];
    const groupItemsDisabled = groupItems.every(groupItem => !groupItem.checked);

    // Update URL query parameters when a filter group is clicked
    handleUrlParamsUpdateOnGroupFilter(groupType, groupItems, groupItemsDisabled);
    if ((0, _nodeListItems.isTagType)(groupType)) {
      onToggleTagFilter(groupItems.map(item => item.id), groupItemsDisabled);
    } else if ((0, _nodeListItems.isElementType)(groupType)) {
      onToggleTypeDisabled(groupItems.reduce((state, item) => ({
        ...state,
        [item.id]: !groupItemsDisabled
      }), {}));
    }
  };
  const handleToggleModularPipelineExpanded = expanded => {
    onToggleModularPipelineExpanded(expanded);
  };
  const onGroupItemChange = (item, wasChecked) => {
    // Toggle the group
    if ((0, _nodeListItems.isTagType)(item.type)) {
      onToggleTagFilter(item.id, !wasChecked);
    } else if ((0, _nodeListItems.isElementType)(item.type)) {
      onToggleTypeDisabled({
        [item.id]: wasChecked
      });
    }

    // Reset node selection
    onToggleNodeSelected(null);
    onToggleNodeActive(null);
  };

  // Deselect node on Escape key
  const handleKeyDown = event => {
    if (event.keyCode === 27) {
      onToggleNodeSelected(null);
    }
  };

  // Reset applied filters to default
  const onResetFilter = () => {
    onToggleTypeDisabled({
      task: false,
      data: false,
      parameters: true
    });
    onToggleTagFilter(tags.map(item => item.id), false);
    toUpdateUrlParamsOnResetFilter();
  };

  // Helper function to check if NodeTypes is modified
  const hasModifiedNodeTypes = nodeTypes => {
    return nodeTypes.some(item => {
      var _NODE_TYPES$item$id;
      return ((_NODE_TYPES$item$id = _config.NODE_TYPES[item.id]) === null || _NODE_TYPES$item$id === void 0 ? void 0 : _NODE_TYPES$item$id.defaultState) !== item.disabled;
    });
  };

  // Updates the reset filter button status based on the node types and tags.
  (0, _react.useEffect)(() => {
    const isNodeTypeModified = hasModifiedNodeTypes(nodeTypes);
    const isNodeTagModified = tags.some(tag => tag.enabled);
    setIsResetFilterActive(isNodeTypeModified || isNodeTagModified);
  }, [tags, nodeTypes]);
  (0, _react.useEffect)(() => {
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  });
  return /*#__PURE__*/_react.default.createElement(_nodeList.default, {
    faded: faded,
    items: items,
    modularPipelinesTree: modularPipelinesTree,
    modularPipelinesSearchResult: modularPipelinesSearchResult,
    groups: groups,
    searchValue: searchValue,
    onUpdateSearchValue: (0, _debounce.default)(updateSearchValue, 250),
    onModularPipelineToggleExpanded: handleToggleModularPipelineExpanded,
    onGroupToggleChanged: onGroupToggleChanged,
    onToggleFocusMode: onToggleFocusMode,
    onItemClick: onItemClick,
    onItemMouseEnter: onItemMouseEnter,
    onItemMouseLeave: onItemMouseLeave,
    onItemChange: onItemChange,
    focusMode: focusMode,
    disabledModularPipeline: disabledModularPipeline,
    onResetFilter: onResetFilter,
    isResetFilterActive: isResetFilterActive
  });
};
const mapStateToProps = state => ({
  tags: (0, _tags.getTagData)(state),
  tagNodeCounts: (0, _tags.getTagNodeCounts)(state),
  nodes: (0, _nodes.getGroupedNodes)(state),
  nodeSelected: (0, _nodes.getNodeSelected)(state),
  nodeTypes: (0, _nodeTypes.getNodeTypes)(state),
  focusMode: (0, _modularPipelines.getFocusedModularPipeline)(state),
  disabledModularPipeline: state.modularPipeline.disabled,
  inputOutputDataNodes: (0, _nodes.getInputOutputNodesForFocusedModularPipeline)(state),
  modularPipelinesTree: (0, _nodes.getModularPipelinesTree)(state)
});
exports.mapStateToProps = mapStateToProps;
const mapDispatchToProps = dispatch => ({
  onToggleTagActive: (tagIDs, active) => {
    dispatch((0, _tags2.toggleTagActive)(tagIDs, active));
  },
  onToggleTagFilter: (tagIDs, enabled) => {
    dispatch((0, _tags2.toggleTagFilter)(tagIDs, enabled));
  },
  onToggleModularPipelineActive: (modularPipelineIDs, active) => {
    dispatch((0, _modularPipelines2.toggleModularPipelineActive)(modularPipelineIDs, active));
  },
  onToggleModularPipelineDisabled: (modularPipelineIDs, disabled) => {
    dispatch((0, _modularPipelines2.toggleModularPipelineDisabled)(modularPipelineIDs, disabled));
  },
  onToggleTypeDisabled: (typeID, disabled) => {
    dispatch((0, _nodeType.toggleTypeDisabled)(typeID, disabled));
  },
  onToggleNodeSelected: nodeID => {
    dispatch((0, _nodes2.loadNodeData)(nodeID));
  },
  onToggleModularPipelineExpanded: expanded => {
    dispatch((0, _modularPipelines2.toggleModularPipelinesExpanded)(expanded));
  },
  onToggleNodeActive: nodeID => {
    dispatch((0, _nodes2.toggleNodeHovered)(nodeID));
  },
  onToggleParametersActive: active => {
    dispatch((0, _actions.toggleParametersHovered)(active));
  },
  onToggleNodesDisabled: (nodeIDs, disabled) => {
    dispatch((0, _nodes2.toggleNodesDisabled)(nodeIDs, disabled));
  },
  onToggleFocusMode: modularPipeline => {
    dispatch((0, _actions.toggleFocusMode)(modularPipeline));
  }
});
exports.mapDispatchToProps = mapDispatchToProps;
var _default = exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(NodeListProvider);