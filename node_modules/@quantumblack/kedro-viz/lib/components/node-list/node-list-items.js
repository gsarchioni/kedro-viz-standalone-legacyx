"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeMatchesSearch = exports.isTagType = exports.isGroupType = exports.isElementType = exports.highlightMatch = exports.getNodeIDs = exports.getGroups = exports.getFilteredTags = exports.getFilteredTagItems = exports.getFilteredNodes = exports.getFilteredNodeItems = exports.getFilteredItems = exports.getFilteredElementTypes = exports.getFilteredElementTypeItems = exports.filterNodeGroups = void 0;
var _reselect = require("reselect");
var _config = require("../../config");
var _indicator = _interopRequireDefault(require("../icons/indicator"));
var _indicatorOff = _interopRequireDefault(require("../icons/indicator-off"));
var _indicatorPartial = _interopRequireDefault(require("../icons/indicator-partial"));
var _invisible = _interopRequireDefault(require("../icons/invisible"));
var _visible = _interopRequireDefault(require("../icons/visible"));
var _searchUtils = require("../../utils/search-utils");
const isTagType = type => type === 'tag';
exports.isTagType = isTagType;
const isElementType = type => type === 'elementType';
exports.isElementType = isElementType;
const isGroupType = type => isElementType(type) || isTagType(type);

/**
 * Get a list of IDs of the visible nodes from all groups
 * @param {Object} nodeGroups Grouped lists of nodes by type
 * @return {Array} List of node IDs
 */
exports.isGroupType = isGroupType;
const getNodeIDs = nodeGroups => Object.values(nodeGroups).flatMap(nodes => nodes.map(node => node.id));

/**
 * Add a new highlightedLabel field to each of the node objects
 * @param {Object} nodeGroups Grouped lists of nodes by type
 * @param {String} searchValue Search term
 * @return {Object} The grouped nodes with highlightedLabel fields added
 */
exports.getNodeIDs = getNodeIDs;
const highlightMatch = (nodeGroups, searchValue) => {
  const highlightedGroups = {};
  for (const type of Object.keys(nodeGroups)) {
    highlightedGroups[type] = nodeGroups[type].map(node => ({
      ...node,
      highlightedLabel: (0, _searchUtils.getHighlightedText)(node.name, searchValue)
    }));
  }
  return highlightedGroups;
};

/**
 * Check whether a node matches the search text or true if no search value given
 * @param {Object} node
 * @param {String} searchValue
 * @return {Boolean} True if node matches or no search value given
 */
exports.highlightMatch = highlightMatch;
const nodeMatchesSearch = (node, searchValue) => {
  if (searchValue) {
    return new RegExp((0, _searchUtils.escapeRegExp)(searchValue), 'gi').test(node.name);
  }
  return true;
};

/**
 * Return only the results that match the search text
 * @param {Object} nodeGroups Grouped lists of nodes by type
 * @param {String} searchValue Search term
 * @return {Object} Grouped nodes
 */
exports.nodeMatchesSearch = nodeMatchesSearch;
const filterNodeGroups = (nodeGroups, searchValue) => {
  const filteredGroups = {};
  for (const nodeGroupId of Object.keys(nodeGroups)) {
    filteredGroups[nodeGroupId] = nodeGroups[nodeGroupId].filter(node => nodeMatchesSearch(node, searchValue));
  }
  return filteredGroups;
};

/**
 * Return filtered/highlighted nodes, and filtered node IDs
 * @param {Object} nodeGroups Grouped lists of nodes by type
 * @param {String} searchValue Search term
 * @return {Object} Grouped nodes, and node IDs
 */
exports.filterNodeGroups = filterNodeGroups;
const getFilteredNodes = exports.getFilteredNodes = (0, _reselect.createSelector)([state => state.nodes, state => state.searchValue], (nodeGroups, searchValue) => {
  const filteredGroups = filterNodeGroups(nodeGroups, searchValue);
  return {
    filteredNodes: highlightMatch(filteredGroups, searchValue),
    nodeIDs: getNodeIDs(filteredGroups)
  };
});

/**
 * Return filtered/highlighted tags
 * @param {Object} tags List of tags
 * @param {String} searchValue Search term
 * @return {Object} Grouped tags
 */
const getFilteredTags = exports.getFilteredTags = (0, _reselect.createSelector)([state => state.tags, state => state.searchValue], (tags, searchValue) => highlightMatch(filterNodeGroups({
  tag: tags
}, searchValue), searchValue));

/**
 * Return filtered/highlighted tag list items
 * @param {Object} filteredTags List of filtered tags
 * @return {Array} Node list items
 */
const getFilteredTagItems = exports.getFilteredTagItems = (0, _reselect.createSelector)([getFilteredTags, state => state.tagNodeCounts], function (filteredTags) {
  let tagNodeCounts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  return {
    tag: filteredTags.tag.map(tag => ({
      ...tag,
      type: 'tag',
      visibleIcon: _indicator.default,
      invisibleIcon: _indicatorOff.default,
      active: false,
      selected: false,
      faded: false,
      visible: true,
      disabled: false,
      checked: tag.enabled,
      count: tagNodeCounts[tag.id] || 0
    }))
  };
});

/**
 * Return filtered/highlighted element types
 * @param {String} searchValue Search term
 * @return {Object} Grouped element types
 */
const getFilteredElementTypes = exports.getFilteredElementTypes = (0, _reselect.createSelector)([state => state.searchValue], searchValue => highlightMatch(filterNodeGroups({
  elementType: Object.entries(_config.sidebarElementTypes).map(_ref => {
    let [type, name] = _ref;
    return {
      id: type,
      name
    };
  })
}, searchValue), searchValue));

/**
 * Return filtered/highlighted element type items
 * @param {Object} filteredTags List of filtered element types
 * @param {Array} nodeTypes List of node types
 * @return {Object} Element type items
 */
const getFilteredElementTypeItems = exports.getFilteredElementTypeItems = (0, _reselect.createSelector)([getFilteredElementTypes, state => state.nodeTypes], (filteredElementTypes, nodeTypes) => ({
  elementType: filteredElementTypes.elementType.map(elementType => {
    const nodeType = nodeTypes.find(type => type.id === elementType.id);
    return {
      ...elementType,
      type: 'elementType',
      visibleIcon: _indicator.default,
      invisibleIcon: _indicatorOff.default,
      active: false,
      selected: false,
      faded: false,
      visible: true,
      disabled: false,
      checked: nodeType.disabled === false,
      count: nodeType.nodeCount.total
    };
  })
}));

/**
 * Compares items for sorting in groups first
 * by enabled status (by tag) and then alphabeticaly (by name)
 * @param {Object} itemA First item to compare
 * @param {Object} itemB Second item to compare
 * @return {Number} Comparison result
 */
const compareEnabledThenAlpha = (itemA, itemB) => {
  const byEnabledTag = Number(itemA.disabledTag) - Number(itemB.disabledTag);
  const byAlpha = itemA.name.localeCompare(itemB.name);
  return byEnabledTag !== 0 ? byEnabledTag : byAlpha;
};

/**
 * Compares items for sorting in groups first
 * by enabled status (by tag) and then alphabeticaly (by name)
 * @param {Object} itemA First item to compare
 * @param {Object} itemB Second item to compare
 * @return {Number} Comparison result
 */
const getFilteredNodeItems = exports.getFilteredNodeItems = (0, _reselect.createSelector)([getFilteredNodes, state => state.nodeSelected, state => state.focusMode, state => state.inputOutputDataNodes], (_ref2, nodeSelected, focusMode, inputOutputDataNodes) => {
  let {
    filteredNodes
  } = _ref2;
  const filteredNodeItems = {};
  for (const type of Object.keys(filteredNodes)) {
    filteredNodeItems[type] = filteredNodes[type].map(node => {
      const checked = !node.disabledNode;
      const disabled = node.disabledTag || node.disabledType || focusMode !== null && !!inputOutputDataNodes[node.id];
      return {
        ...node,
        visibleIcon: _visible.default,
        invisibleIcon: _invisible.default,
        active: undefined,
        selected: nodeSelected[node.id],
        faded: disabled || node.disabledNode,
        visible: !disabled && checked,
        checked,
        disabled
      };
    }).sort(compareEnabledThenAlpha);
  }
  return filteredNodeItems;
});

/**
 * Returns group items for each sidebar filter group defined in the sidebar config.
 * @param {Object} items List items by group type
 * @return {Array} List of groups
 */
const getGroups = exports.getGroups = (0, _reselect.createSelector)([state => state.items], items => {
  const groups = {};
  for (const [type, name] of Object.entries(_config.sidebarGroups)) {
    const itemsOfType = items[type] || [];
    const allUnchecked = itemsOfType.every(item => !item.checked);
    const allChecked = itemsOfType.every(item => item.checked);
    groups[type] = {
      type,
      name,
      id: type,
      kind: 'filter',
      allUnchecked: itemsOfType.every(item => !item.checked),
      allChecked: itemsOfType.every(item => item.checked),
      checked: !allUnchecked,
      visibleIcon: allChecked ? _indicator.default : _indicatorPartial.default,
      invisibleIcon: _indicatorOff.default
    };
  }
  return groups;
});

/**
 * Returns filtered/highlighted items for nodes & tags
 * @param {Object} filteredNodeItems List of filtered nodes
 * @param {Object} filteredTagItems List of filtered tags
 * @param {Object} getFilteredElementTypeItems List of filtered element type items
 * @return {Array} final list of all filtered items from the three filtered item sets
 */
const getFilteredItems = exports.getFilteredItems = (0, _reselect.createSelector)([getFilteredNodeItems, getFilteredTagItems, getFilteredElementTypeItems], (filteredNodeItems, filteredTagItems, filteredElementTypeItems) => ({
  ...filteredTagItems,
  ...filteredNodeItems,
  ...filteredElementTypeItems
}));