"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nodeListRowHeight = exports.mapStateToProps = exports.mapDispatchToProps = exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactRedux = require("react-redux");
var _classnames = _interopRequireDefault(require("classnames"));
var _utils = require("../../utils");
var _nodeIcon = _interopRequireDefault(require("../icons/node-icon"));
var _visible = _interopRequireDefault(require("../icons/visible"));
var _invisible = _interopRequireDefault(require("../icons/invisible"));
var _focusMode = _interopRequireDefault(require("../icons/focus-mode"));
var _nodes = require("../../selectors/nodes");
var _actions = require("../../actions");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
// The exact fixed height of a row as measured by getBoundingClientRect()
const nodeListRowHeight = exports.nodeListRowHeight = 32;

/**
 * Returns `true` if there are no props changes, therefore the last render can be reused.
 * Performance: Checks only the minimal set of props known to change after first render.
 */
const shouldMemo = (prevProps, nextProps) => !(0, _utils.changed)(['active', 'checked', 'allUnchecked', 'disabled', 'faded', 'focused', 'visible', 'selected', 'label', 'children', 'count'], prevProps, nextProps);
const NodeListRow = /*#__PURE__*/(0, _react.memo)(_ref => {
  let {
    container: Container = 'div',
    active,
    checked,
    allUnchecked,
    children,
    disabled,
    faded,
    focused,
    visible,
    id,
    label,
    count,
    name,
    kind,
    onMouseEnter,
    onMouseLeave,
    onChange,
    onClick,
    selected,
    type,
    icon,
    visibleIcon = _visible.default,
    invisibleIcon = _invisible.default,
    focusModeIcon = _focusMode.default,
    rowType,
    onToggleHoveredFocusMode
  } = _ref;
  const isModularPipeline = type === 'modularPipeline';
  const FocusIcon = isModularPipeline ? focusModeIcon : null;
  const isChecked = isModularPipeline ? checked || focused : checked;
  const VisibilityIcon = isChecked ? visibleIcon : invisibleIcon;
  const isButton = onClick && kind !== 'filter';
  const TextButton = isButton ? 'button' : 'div';
  return /*#__PURE__*/_react.default.createElement(Container, {
    className: (0, _classnames.default)('pipeline-nodelist__row kedro', "pipeline-nodelist__row--kind-".concat(kind), {
      'pipeline-nodelist__row--visible': visible,
      'pipeline-nodelist__row--active': active,
      'pipeline-nodelist__row--selected': selected,
      'pipeline-nodelist__row--disabled': disabled,
      'pipeline-nodelist__row--unchecked': !isChecked,
      'pipeline-nodelist__row--overwrite': !(active || selected)
    }),
    title: name,
    onMouseEnter: visible ? onMouseEnter : null,
    onMouseLeave: visible ? onMouseLeave : null
  }, icon && /*#__PURE__*/_react.default.createElement(_nodeIcon.default, {
    className: (0, _classnames.default)('pipeline-nodelist__row__type-icon', 'pipeline-nodelist__row__icon', {
      'pipeline-nodelist__row__type-icon--faded': faded,
      'pipeline-nodelist__row__type-icon--disabled': disabled,
      'pipeline-nodelist__row__type-icon--nested': !children,
      'pipeline-nodelist__row__type-icon--active': active,
      'pipeline-nodelist__row__type-icon--selected': selected
    }),
    icon: icon
  }), /*#__PURE__*/_react.default.createElement(TextButton, {
    className: (0, _classnames.default)('pipeline-nodelist__row__text', "pipeline-nodelist__row__text--kind-".concat(kind), "pipeline-nodelist__row__text--".concat(rowType)),
    "data-test": "nodelist-".concat(icon, "-").concat(children ? null : name),
    onClick: onClick,
    onFocus: onMouseEnter,
    onBlur: onMouseLeave,
    title: children ? null : name
  }, /*#__PURE__*/_react.default.createElement("span", {
    className: (0, _classnames.default)('pipeline-nodelist__row__label', "pipeline-nodelist__row__label--kind-".concat(kind), {
      'pipeline-nodelist__row__label--faded': faded,
      'pipeline-nodelist__row__label--disabled': disabled
    }),
    dangerouslySetInnerHTML: {
      __html: (0, _utils.replaceAngleBracketMatches)(label)
    }
  })), typeof count === 'number' && /*#__PURE__*/_react.default.createElement("span", {
    onClick: onClick,
    className: 'pipeline-nodelist__row__count'
  }, count), VisibilityIcon && /*#__PURE__*/_react.default.createElement("label", {
    htmlFor: id,
    className: (0, _classnames.default)('pipeline-row__toggle', "pipeline-row__toggle--kind-".concat(kind), {
      'pipeline-row__toggle--disabled': isModularPipeline ? focused : disabled,
      'pipeline-row__toggle--selected': selected
    }),
    onClick: e => e.stopPropagation()
  }, /*#__PURE__*/_react.default.createElement("input", {
    id: id,
    className: "pipeline-nodelist__row__checkbox",
    "data-test": kind === "nodelist-visible-".concat(name, "-").concat(isChecked),
    type: "checkbox",
    checked: isChecked,
    disabled: disabled,
    name: name,
    onChange: onChange
  }), /*#__PURE__*/_react.default.createElement(VisibilityIcon, {
    "aria-label": name,
    checked: isChecked,
    className: (0, _classnames.default)('pipeline-nodelist__row__icon', 'pipeline-row__toggle-icon', "pipeline-row__toggle-icon--kind-".concat(kind), {
      'pipeline-row__toggle-icon--parent': Boolean(children),
      'pipeline-row__toggle-icon--child': !children,
      'pipeline-row__toggle-icon--checked': isChecked,
      'pipeline-row__toggle-icon--unchecked': !isChecked,
      'pipeline-row__toggle-icon--all-unchecked': allUnchecked,
      'pipeline-row__toggle-icon--focus-checked': isModularPipeline ? false : focused
    })
  })), FocusIcon && /*#__PURE__*/_react.default.createElement("label", {
    htmlFor: id + '-focus',
    className: (0, _classnames.default)('pipeline-row__toggle', "pipeline-row__toggle--kind-".concat(kind), {
      'pipeline-row__toggle--disabled': disabled,
      'pipeline-row__toggle--selected': selected
    }),
    onClick: e => e.stopPropagation(),
    onMouseEnter: () => onToggleHoveredFocusMode(true),
    onMouseLeave: () => onToggleHoveredFocusMode(false)
  }, /*#__PURE__*/_react.default.createElement("input", {
    id: id + '-focus',
    className: "pipeline-nodelist__row__checkbox",
    "data-test": kind === "nodelist-focusMode-checked-".concat(isChecked),
    type: "checkbox",
    checked: isChecked,
    disabled: disabled,
    name: name,
    onChange: onChange,
    "data-icon-type": "focus"
  }), /*#__PURE__*/_react.default.createElement(FocusIcon, {
    "aria-label": name,
    checked: isChecked,
    className: (0, _classnames.default)('pipeline-nodelist__row__icon', 'pipeline-row__toggle-icon', "pipeline-row__toggle-icon--kind-".concat(kind), {
      'pipeline-row__toggle-icon--parent': Boolean(children),
      'pipeline-row__toggle-icon--child': !children,
      'pipeline-row__toggle-icon--checked': isChecked,
      'pipeline-row__toggle-icon--unchecked': !isChecked,
      'pipeline-row__toggle-icon--all-unchecked': allUnchecked,
      'pipeline-row__toggle-icon--focus-checked': focused
    })
  })), children);
}, shouldMemo);
const mapDispatchToProps = dispatch => ({
  onToggleHoveredFocusMode: active => {
    dispatch((0, _actions.toggleHoveredFocusMode)(active));
  }
});
exports.mapDispatchToProps = mapDispatchToProps;
const mapStateToProps = (state, ownProps) => ({
  ...ownProps,
  active: typeof ownProps.active !== 'undefined' ? ownProps.active : (0, _nodes.getNodeActive)(state)[ownProps.id] || false
});
exports.mapStateToProps = mapStateToProps;
var _default = exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(NodeListRow);