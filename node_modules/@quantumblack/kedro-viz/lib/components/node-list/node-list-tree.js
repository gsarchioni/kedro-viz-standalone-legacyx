"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapStateToProps = exports.mapDispatchToProps = exports.default = void 0;
var _react = _interopRequireDefault(require("react"));
var _reactRedux = require("react-redux");
var _system = require("@mui/system");
var _xTreeView = require("@mui/x-tree-view");
var _ExpandMore = _interopRequireDefault(require("@mui/icons-material/ExpandMore"));
var _ChevronRight = _interopRequireDefault(require("@mui/icons-material/ChevronRight"));
var _sortBy = _interopRequireDefault(require("lodash/sortBy"));
var _nodes = require("../../actions/nodes");
var _nodes2 = require("../../selectors/nodes");
var _nodeTypes = require("../../selectors/node-types");
var _nodeListTreeItem = _interopRequireDefault(require("./node-list-tree-item"));
var _visible = _interopRequireDefault(require("../icons/visible"));
var _invisible = _interopRequireDefault(require("../icons/invisible"));
var _focusMode = _interopRequireDefault(require("../icons/focus-mode"));
// Display order of node groups
const GROUPED_NODES_DISPLAY_ORDER = {
  modularPipeline: 0,
  task: 1,
  data: 2,
  parameter: 3
};

// please note that this setup is unique for initialization of the material-ui tree,
// and setup is only used here and not anywhere else in the app.
const StyledTreeView = (0, _system.styled)(_xTreeView.TreeView)({
  root: {
    height: 110,
    flexGrow: 1,
    maxWidth: 400
  },
  padding: '0 0 0 20px'
});

/**
 * Return whether the given modular pipeline ID is on focus mode path, i.e.
 * it's not the currently focused pipeline nor one of its children.
 * @param {String} focusModeID The currently focused modular pipeline ID.
 * @param {String} modularPipelineID The modular pipeline ID to check.
 * @return {Boolean} Whether the given modular pipeline ID is on focus mode path.
 */
const isOnFocusedModePath = (focusModeID, modularPipelineID) => {
  return modularPipelineID === focusModeID || modularPipelineID.startsWith("".concat(focusModeID, "."));
};

/**
 * Return the data of a modular pipeline to display as a row in the node list.
 * @param {Object} params
 * @param {String} params.id The modular pipeline ID
 * @param {String} params.highlightedLabel The modular pipeline name with highlights when matched under search
 * @param {Object} params.data The modular pipeline data to display
 * @param {Boolean} params.disabled Whether the modular pipeline is disabled, e.g. when it's not the focused one
 * @param {Boolean} params.focused Whether the modular pipeline is the focused one in focus mode
 * @return {Object} The modular pipeline's data needed to render as a row in the node list tree.
 */
const getModularPipelineRowData = _ref => {
  let {
    id,
    highlightedLabel,
    data,
    disabled,
    focused,
    focusModeIcon
  } = _ref;
  const checked = !data.disabledModularPipeline;
  return {
    id: id,
    name: highlightedLabel || data.name,
    type: 'modularPipeline',
    icon: 'modularPipeline',
    focusModeIcon: focusModeIcon,
    active: false,
    selected: false,
    faded: disabled || !checked,
    visible: !disabled && checked,
    enabled: true,
    disabled: disabled,
    focused: focused,
    checked
  };
};

/**
 * Return the data of a node to display as a row in the node list
 * @param {Object} node The node to display
 * @param {Boolean} selected Whether the node is currently disabled
 * @param {Boolean} selected Whether the node is currently selected
 */
const getNodeRowData = (node, disabled, selected) => {
  const checked = !node.disabledNode;
  return {
    ...node,
    visibleIcon: _visible.default,
    invisibleIcon: _invisible.default,
    active: node.active,
    selected,
    faded: disabled || node.disabledNode,
    visible: !disabled && checked,
    checked,
    disabled
  };
};
const TreeListProvider = _ref2 => {
  let {
    nodeSelected,
    modularPipelinesSearchResult,
    modularPipelinesTree,
    onItemChange,
    onItemMouseEnter,
    onItemMouseLeave,
    onItemClick,
    onNodeToggleExpanded,
    focusMode,
    disabledModularPipeline,
    expanded,
    onToggleNodeSelected
  } = _ref2;
  // render a leaf node in the modular pipelines tree
  const renderLeafNode = node => {
    const disabled = node.disabledTag || node.disabledType || focusMode && !node.modularPipelines.map(modularPipelineID => isOnFocusedModePath(focusMode.id, modularPipelineID)).some(Boolean) || node.modularPipelines && node.modularPipelines.map(modularPipelineID => disabledModularPipeline[modularPipelineID]).some(Boolean);
    const selected = nodeSelected[node.id];
    return /*#__PURE__*/_react.default.createElement(_nodeListTreeItem.default, {
      data: getNodeRowData(node, disabled, selected),
      onItemMouseEnter: onItemMouseEnter,
      onItemMouseLeave: onItemMouseLeave,
      onItemChange: onItemChange,
      onItemClick: onItemClick,
      key: node.id
    });
  };

  // recursively renders the modular pipeline tree
  const renderTree = (tree, modularPipelineID) => {
    // current tree node to render
    const node = tree[modularPipelineID];
    if (!node) {
      return;
    }

    // render each child of the tree node first
    const children = (0, _sortBy.default)(node.children, child => GROUPED_NODES_DISPLAY_ORDER[child.type], child => child.data.name).map(child => (0, _nodeTypes.isModularPipelineType)(child.type) ? renderTree(tree, child.id) : renderLeafNode(child.data));

    // then render the node itself wrapping around the children
    // except when it's the root node,
    // because we don't want to display the __root__ modular pipeline.
    if (modularPipelineID === '__root__') {
      return children;
    }
    const isFocusedModularPipeline = (focusMode === null || focusMode === void 0 ? void 0 : focusMode.id) === node.id;
    let focusModeIcon;
    if (!focusMode) {
      focusModeIcon = _focusMode.default;
    } else {
      focusModeIcon = isFocusedModularPipeline ? _focusMode.default : null;
    }
    return /*#__PURE__*/_react.default.createElement(_nodeListTreeItem.default, {
      data: getModularPipelineRowData({
        ...node,
        focusModeIcon,
        disabled: focusMode && !isOnFocusedModePath(focusMode.id, node.id),
        focused: isFocusedModularPipeline
      }),
      onItemMouseEnter: onItemMouseEnter,
      onItemMouseLeave: onItemMouseLeave,
      onItemChange: onItemChange,
      onItemClick: onItemClick,
      key: node.id
    }, children);
  };
  const onItemExpandCollapseToggle = (event, expandedItemIds) => {
    onNodeToggleExpanded(expandedItemIds);
    //when the parent modular pipeline tree of the selected node is collapsed
    if (expandedItemIds.length === 0) {
      onToggleNodeSelected(null);
    }
  };
  return modularPipelinesSearchResult ? /*#__PURE__*/_react.default.createElement(StyledTreeView, {
    expanded: Object.keys(modularPipelinesSearchResult),
    defaultCollapseIcon: /*#__PURE__*/_react.default.createElement(_ExpandMore.default, null),
    defaultExpandIcon: /*#__PURE__*/_react.default.createElement(_ChevronRight.default, null),
    key: "modularPipelinesSearchResult"
  }, renderTree(modularPipelinesSearchResult, '__root__')) : /*#__PURE__*/_react.default.createElement(StyledTreeView, {
    expanded: expanded,
    defaultCollapseIcon: /*#__PURE__*/_react.default.createElement(_ExpandMore.default, null),
    defaultExpandIcon: /*#__PURE__*/_react.default.createElement(_ChevronRight.default, null),
    onNodeToggle: onItemExpandCollapseToggle,
    key: "modularPipelinesTree"
  }, renderTree(modularPipelinesTree, '__root__'));
};
const mapStateToProps = state => ({
  nodeSelected: (0, _nodes2.getNodeSelected)(state),
  expanded: state.modularPipeline.expanded
});
exports.mapStateToProps = mapStateToProps;
const mapDispatchToProps = dispatch => ({
  onToggleNodeSelected: nodeID => {
    dispatch((0, _nodes.loadNodeData)(nodeID));
  }
});
exports.mapDispatchToProps = mapDispatchToProps;
var _default = exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(TreeListProvider);