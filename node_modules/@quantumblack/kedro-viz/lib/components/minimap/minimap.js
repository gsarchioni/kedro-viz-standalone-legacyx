"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapStateToProps = exports.mapDispatchToProps = exports.default = exports.MiniMap = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _reactRedux = require("react-redux");
require("d3-transition");
var _d3Selection = require("d3-selection");
var _nodes = require("../../selectors/nodes");
var _actions = require("../../actions");
var _layout = require("../../selectors/layout");
var _linkedNodes = require("../../selectors/linked-nodes");
var _view = require("../../utils/view");
var _draw = require("./draw");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Display a pipeline minimap, mostly rendered with D3
 */
class MiniMap extends _react.Component {
  constructor(props) {
    var _this;
    super(props);
    _this = this;
    /**
     * Handle pointer enter
     */
    this.onPointerEnter = () => {
      this.isPointerInside = true;
    };
    /**
     * Handle pointer leave
     */
    this.onPointerLeave = () => {
      this.isPointerInside = false;
    };
    /**
     * Handle global pointer up
     */
    this.onPointerUpGlobal = () => {
      this.isPointerDown = false;
      this.isPointerInside = false;
    };
    /**
     * Handle pointer down
     * @param {Object} event Event object
     */
    this.onPointerDown = event => {
      this.isPointerDown = true;
      this.isPointerInside = true;
      this.onPointerMove(event, true);
    };
    /**
     * Handle pointer wheel
     * @param {Object} event Event object
     */
    this.onPointerWheel = event => {
      // Change zoom based on wheel velocity
      this.props.onUpdateChartZoom({
        relative: true,
        scale: -(event.deltaY || 0) * this.ZOOM_RATE,
        applied: false,
        transition: false
      });
    };
    /**
     * Handle global pointer wheel
     * @param {Object} event Event object
     */
    this.onPointerWheelGlobal = event => {
      // Prevent window scroll when wheeling on this minimap
      const wasTarget = this.containerRef.current.contains(event.target);
      if (wasTarget) {
        event.preventDefault();
      }
    };
    /**
     * Handle pointer move
     * @param {Object} event Event object
     * @param {?Boolean} useTransition Apply with transition
     */
    this.onPointerMove = function (event) {
      let useTransition = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      if (_this.isPointerDown && _this.isPointerInside) {
        // Wait for transition
        const time = Number(new Date());
        if (time - _this.lastTransitionTime < _this.TRANSITION_WAIT) {
          return;
        }

        // Get current state
        const {
          scale: chartScale = 1
        } = _this.props.chartZoom;
        const {
          width,
          height
        } = _this.props.mapSize;
        const {
          width: graphWidth,
          height: graphHeight
        } = _this.props.graphSize;
        const {
          k: scale = 1
        } = (0, _view.getViewTransform)(_this.view);
        const containerRect = _this.svgRef.current.getBoundingClientRect();

        // Transform minimap pointer position to a graph position
        const pointerX = (event.clientX - containerRect.x) / scale;
        const pointerY = (event.clientY - containerRect.y) / scale;
        const centerX = (width / scale - graphWidth) * 0.5;
        const centerY = (height / scale - graphHeight) * 0.5;
        const x = (pointerX - centerX) * chartScale;
        const y = (pointerY - centerY) * chartScale;

        // Dispatch an update to be applied
        _this.props.onUpdateChartZoom({
          x,
          y,
          scale: chartScale,
          relative: false,
          applied: false,
          transition: useTransition
        });
        if (useTransition) {
          _this.lastTransitionTime = time;
        }
      }
    };
    this.DURATION = 700;
    this.TRANSITION_WAIT = 200;
    this.ZOOM_RATE = 0.0025;
    this.isPointerDown = false;
    this.isPointerInside = false;
    this.lastTransitionTime = 0;
    this.containerRef = /*#__PURE__*/_react.default.createRef();
    this.svgRef = /*#__PURE__*/_react.default.createRef();
    this.wrapperRef = /*#__PURE__*/_react.default.createRef();
    this.nodesRef = /*#__PURE__*/_react.default.createRef();
    this.viewportRef = /*#__PURE__*/_react.default.createRef();
    this.onPointerMove = this.onPointerMove.bind(this);
    this.onPointerEnter = this.onPointerEnter.bind(this);
    this.onPointerLeave = this.onPointerLeave.bind(this);
    this.onPointerDown = this.onPointerDown.bind(this);
    this.onPointerWheel = this.onPointerWheel.bind(this);
    this.onPointerWheelGlobal = this.onPointerWheelGlobal.bind(this);
    this.onPointerUpGlobal = this.onPointerUpGlobal.bind(this);
  }
  componentDidMount() {
    this.selectD3Elements();
    this.view = (0, _view.viewing)({
      container: this.svgRef,
      wrapper: this.wrapperRef,
      allowUserInput: false
    });
    this.addGlobalEventListeners();
    this.update();
  }
  componentWillUnmount() {
    this.removeGlobalEventListeners();
  }

  /**
   * Add window event listeners
   */
  addGlobalEventListeners() {
    window.addEventListener('wheel', this.onPointerWheelGlobal, {
      passive: false
    });
    window.addEventListener(pointerEventName('pointerup'), this.onPointerUpGlobal);
  }

  /**
   * Remove window event listeners
   */
  removeGlobalEventListeners() {
    window.removeEventListener('wheel', this.onPointerWheelGlobal);
    window.removeEventListener(pointerEventName('pointerup'), this.onPointerUpGlobal);
  }
  componentDidUpdate(prevProps) {
    this.update(prevProps);
  }

  /**
   * Updates drawing and zoom if props have changed
   */
  update() {
    var _this2 = this;
    let prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      miniMapVisible,
      chartZoom
    } = this.props;
    if (miniMapVisible) {
      const changed = function () {
        for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {
          names[_key] = arguments[_key];
        }
        return _this2.changed(names, prevProps, _this2.props);
      };
      if (changed('miniMapVisible', 'nodes', 'clickedNodes', 'linkedNodes', 'nodesActive', 'nodeSelected')) {
        _draw.drawNodes.call(this);
      }
      if (changed('miniMapVisible', 'chartZoom') && chartZoom.applied) {
        _draw.drawViewport.call(this);
      }
      if (changed('miniMapVisible', 'nodes', 'textLabels', 'chartSize')) {
        this.resetView();
      }
    }
  }

  /**
   * Returns true if any of the given props are different between given objects.
   * Only shallow changes are detected.
   */
  changed(props, objectA, objectB) {
    return objectA && objectB && props.some(prop => objectA[prop] !== objectB[prop]);
  }

  /**
   * Create D3 element selectors
   */
  selectD3Elements() {
    this.el = {
      svg: (0, _d3Selection.select)(this.svgRef.current),
      wrapper: (0, _d3Selection.select)(this.wrapperRef.current),
      nodeGroup: (0, _d3Selection.select)(this.nodesRef.current),
      viewport: (0, _d3Selection.select)(this.viewportRef.current)
    };
  }
  /**
   * Zoom and scale to fit
   */
  resetView() {
    const {
      graphSize,
      mapSize
    } = this.props;
    const {
      width: mapWidth,
      height: mapHeight
    } = mapSize;
    const {
      width: graphWidth,
      height: graphHeight
    } = graphSize;

    // Skip if chart or graph is not ready yet
    if (!mapWidth || !graphWidth) {
      return;
    }

    // Padding offset
    const offset = {
      x: padding * 0.5,
      y: padding * 0.5
    };

    // Find a transform that fits everything in view
    const transform = (0, _view.viewTransformToFit)({
      offset,
      viewWidth: mapWidth - padding,
      viewHeight: mapHeight - padding,
      objectWidth: graphWidth,
      objectHeight: graphHeight
    });

    // Detect first transform
    const isFirstTransform = (0, _view.isOrigin)((0, _view.getViewTransform)(this.view));

    // Apply transform ignoring extents
    (0, _view.setViewTransformExact)(this.view, transform, isFirstTransform ? 0 : this.DURATION, false);
  }

  /**
   * Get the position of the viewport relative to the minimap
   */
  getViewport() {
    const {
      chartZoom,
      chartSize
    } = this.props;
    const {
      k: mapScale,
      x: translateX,
      y: translateY
    } = (0, _view.getViewTransform)(this.view);
    const scale = mapScale / chartZoom.scale;
    const width = chartSize.width * scale;
    const height = chartSize.height * scale;
    const x = -translateX - (chartZoom.x - chartSize.sidebarWidth) * scale;
    const y = -translateY - chartZoom.y * scale;
    return {
      x,
      y,
      width,
      height
    };
  }

  /**
   * Render React elements
   */
  render() {
    const {
      width,
      height
    } = this.props.mapSize;
    const transformStyle = {
      transform: "translate(calc(-100% + ".concat(width, "px), -100%)")
    };

    // Add pointer events with back compatibility
    const _ = pointerEventName;
    const inputEvents = {
      onWheel: this.onPointerWheel,
      [_('onPointerEnter')]: this.onPointerEnter,
      [_('onPointerLeave')]: this.onPointerLeave,
      [_('onPointerDown')]: this.onPointerDown,
      [_('onPointerMove')]: this.onPointerMove
    };
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "pipeline-minimap-container",
      style: this.props.miniMapVisible && this.props.displayMiniMap ? transformStyle : {}
    }, /*#__PURE__*/_react.default.createElement("div", (0, _extends2.default)({
      className: "pipeline-minimap kedro",
      ref: this.containerRef
    }, inputEvents), /*#__PURE__*/_react.default.createElement("svg", {
      id: "pipeline-minimap-graph",
      className: "pipeline-minimap__graph",
      width: width,
      height: height,
      viewBox: "0 0 ".concat(width, " ").concat(height),
      ref: this.svgRef
    }, /*#__PURE__*/_react.default.createElement("g", {
      id: "zoom-wrapper",
      ref: this.wrapperRef
    }, /*#__PURE__*/_react.default.createElement("g", {
      id: "minimap-nodes",
      className: "pipeline-minimap__nodes",
      ref: this.nodesRef
    })), /*#__PURE__*/_react.default.createElement("rect", {
      className: "pipeline-minimap__viewport",
      ref: this.viewportRef
    }))));
  }
}

// Map sizing constants
exports.MiniMap = MiniMap;
const padding = 32;
const height = 220;
const minWidth = 218;
const maxWidth = 1.5 * minWidth;

/**
 * Convert pointer event name to a mouse event name if not supported
 */
const pointerEventName = event => window.PointerEvent ? event : event.replace('pointer', 'mouse').replace('Pointer', 'Mouse');

/**
 * Gets the map sizing that fits the graph in state
 */
const getMapSize = state => {
  const size = state.graph.size || {};
  const graphWidth = size.width || 0;
  const graphHeight = size.height || 0;
  if (graphWidth > 0 && graphHeight > 0) {
    // Constrain width
    const scaledWidth = graphWidth * (height / graphHeight);
    const width = Math.min(Math.max(scaledWidth, minWidth), maxWidth);
    return {
      width,
      height
    };
  }

  // Use minimum size if no graph
  return {
    width: minWidth,
    height: height
  };
};

// Maintain a single reference to support change detection
const emptyNodes = [];
const emptyGraphSize = {};
const mapStateToProps = (state, ownProps) => ({
  miniMapVisible: state.visible.miniMap,
  displayMiniMap: state.display.miniMap,
  mapSize: getMapSize(state),
  clickedNode: state.node.clicked,
  chartSize: (0, _layout.getChartSize)(state),
  chartZoom: (0, _layout.getChartZoom)(state),
  graphSize: state.graph.size || emptyGraphSize,
  nodes: state.graph.nodes || emptyNodes,
  linkedNodes: (0, _linkedNodes.getLinkedNodes)(state),
  nodeActive: (0, _nodes.getNodeActive)(state),
  nodeSelected: (0, _nodes.getNodeSelected)(state),
  textLabels: state.textLabels,
  ...ownProps
});
exports.mapStateToProps = mapStateToProps;
const mapDispatchToProps = (dispatch, ownProps) => ({
  onUpdateChartZoom: transform => {
    dispatch((0, _actions.updateZoom)(transform));
  },
  ...ownProps
});
exports.mapDispatchToProps = mapDispatchToProps;
var _default = exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(MiniMap);