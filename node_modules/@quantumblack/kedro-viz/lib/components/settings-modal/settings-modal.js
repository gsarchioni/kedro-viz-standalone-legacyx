"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapStateToProps = exports.mapDispatchToProps = exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactRedux = require("react-redux");
var _actions = require("../../actions");
var _preferences = require("../../actions/preferences");
var _flags = require("../../utils/flags");
var _settingsModalRow = _interopRequireDefault(require("./settings-modal-row"));
var _config = require("../../config");
var _helpers = require("../../store/helpers");
var _featureHints = require("../../components/feature-hints/feature-hints");
var _preferencesApi = require("../../utils/preferences-api");
var _button = _interopRequireDefault(require("../ui/button"));
var _modal = _interopRequireDefault(require("../ui/modal"));
var _utils = require("../../utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Modal to allow users to change the flag settings
 */

const SettingsModal = _ref => {
  let {
    flags,
    showFeatureHints,
    isOutdated,
    isPrettyName,
    showDatasetPreviews,
    latestVersion,
    onToggleFlag,
    onToggleShowFeatureHints,
    onToggleIsPrettyName,
    onToggleShowDatasetPreviews,
    showSettingsModal,
    getPreferences,
    visible
  } = _ref;
  const flagData = (0, _flags.getFlagsState)();
  const [hasNotInteracted, setHasNotInteracted] = (0, _react.useState)(true);
  const [hasClickedApplyAndClose, setHasClickApplyAndClose] = (0, _react.useState)(false);
  const [isPrettyNameValue, setIsPrettyName] = (0, _react.useState)(isPrettyName);
  const [showFeatureHintsValue, setShowFeatureHintsValue] = (0, _react.useState)(showFeatureHints);
  const [showDatasetPreviewsValue, setShowDatasetPreviewsValue] = (0, _react.useState)(showDatasetPreviews);
  const [toggleFlags, setToggleFlags] = (0, _react.useState)(flags);
  (0, _react.useEffect)(() => {
    setShowFeatureHintsValue(showFeatureHints);
  }, [showFeatureHints]);
  (0, _react.useEffect)(() => {
    setShowDatasetPreviewsValue(showDatasetPreviews);
  }, [showDatasetPreviews]);
  (0, _react.useEffect)(() => {
    if (visible.settingsModal) {
      getPreferences();
    }
  }, [visible.settingsModal, getPreferences]);
  const handleSavePreferences = (0, _react.useCallback)(async () => {
    try {
      await (0, _preferencesApi.updatePreferences)(showDatasetPreviewsValue);
    } catch (error) {
      console.error('Error updating preferences:', error);
    }
  }, [showDatasetPreviewsValue]);
  (0, _react.useEffect)(() => {
    let modalTimeout, resetTimeout;
    if (hasClickedApplyAndClose) {
      modalTimeout = setTimeout(() => {
        showSettingsModal(false);
      }, 1500);

      // Delay the reset so the user can't see the button text change.
      resetTimeout = setTimeout(() => {
        const updatedFlags = Object.entries(toggleFlags);
        updatedFlags.map(each => {
          const [name, value] = each;
          return onToggleFlag(name, value);
        });
        handleSavePreferences();
        onToggleIsPrettyName(isPrettyNameValue);
        onToggleShowFeatureHints(showFeatureHintsValue);
        onToggleShowDatasetPreviews(showDatasetPreviewsValue);
        setHasNotInteracted(true);
        setHasClickApplyAndClose(false);
        window.location.reload();
      }, 2000);
    }
    return () => {
      clearTimeout(modalTimeout);
      clearTimeout(resetTimeout);
    };
  }, [hasClickedApplyAndClose, showFeatureHintsValue, isPrettyNameValue, showDatasetPreviewsValue, onToggleFlag, onToggleShowFeatureHints, onToggleIsPrettyName, onToggleShowDatasetPreviews, showSettingsModal, toggleFlags, handleSavePreferences]);
  const resetStateCloseModal = () => {
    showSettingsModal(false);
    setHasNotInteracted(true);
    setToggleFlags(flags);
    setIsPrettyName(isPrettyName);
    setShowFeatureHintsValue(showFeatureHints);
    setShowDatasetPreviewsValue(showDatasetPreviews);
  };
  return /*#__PURE__*/_react.default.createElement("div", {
    className: "pipeline-settings-modal"
  }, /*#__PURE__*/_react.default.createElement(_modal.default, {
    closeModal: resetStateCloseModal,
    title: "Settings",
    visible: visible.settingsModal
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "pipeline-settings-modal__content"
  }, /*#__PURE__*/_react.default.createElement("div", {
    className: "pipeline-settings-modal__group"
  }, /*#__PURE__*/_react.default.createElement(_settingsModalRow.default, {
    id: "isPrettyName",
    name: _config.settings['isPrettyName'].name,
    toggleValue: isPrettyNameValue,
    description: _config.settings['isPrettyName'].description,
    onToggleChange: event => {
      setIsPrettyName(event.target.checked);
      setHasNotInteracted(false);
    }
  }), /*#__PURE__*/_react.default.createElement(_settingsModalRow.default, {
    id: "showFeatureHints",
    name: _config.settings['showFeatureHints'].name,
    toggleValue: showFeatureHintsValue,
    description: _config.settings['showFeatureHints'].description,
    onToggleChange: event => {
      setShowFeatureHintsValue(event.target.checked);
      setHasNotInteracted(false);
      if (event.target.checked === false) {
        (0, _helpers.saveLocalStorage)(_config.localStorageName, {
          [_featureHints.localStorageKeyFeatureHintsStep]: 0
        });
      }
    }
  }), /*#__PURE__*/_react.default.createElement(_settingsModalRow.default, {
    id: "showDatasetPreviews",
    name: _config.settings['showDatasetPreviews'].name,
    toggleValue: showDatasetPreviewsValue,
    description: _config.settings['showDatasetPreviews'].description,
    onToggleChange: event => {
      setShowDatasetPreviewsValue(event.target.checked);
      setHasNotInteracted(false);
    }
  }), flagData.map(_ref2 => {
    let {
      name,
      value,
      description
    } = _ref2;
    return /*#__PURE__*/_react.default.createElement(_settingsModalRow.default, {
      description: description,
      id: value,
      key: value,
      name: name,
      onToggleChange: event => {
        setToggleFlags({
          ...toggleFlags,
          [value]: event.target.checked
        });
        setHasNotInteracted(false);
      },
      toggleValue: toggleFlags[value]
    });
  })), /*#__PURE__*/_react.default.createElement("div", {
    className: "version-reminder-and-run-details-button-wrapper"
  }, (0, _utils.isRunningLocally)() ? isOutdated ? /*#__PURE__*/_react.default.createElement("div", {
    className: "pipeline-settings-modal__upgrade-reminder"
  }, /*#__PURE__*/_react.default.createElement("span", null, "\u2022 Kedro-Viz ", latestVersion, " is here! "), /*#__PURE__*/_react.default.createElement("a", {
    href: "https://github.com/kedro-org/kedro-viz/releases",
    target: "_blank",
    rel: "noopener noreferrer"
  }, "View release notes")) : /*#__PURE__*/_react.default.createElement("div", {
    className: "pipeline-settings-modal__already-latest"
  }, /*#__PURE__*/_react.default.createElement("span", null, "\u2022 You are on the latest version of Kedro-Viz (", latestVersion, ")")) : null, /*#__PURE__*/_react.default.createElement("div", {
    className: "pipeline-settings-modal-buttons"
  }, /*#__PURE__*/_react.default.createElement(_button.default, {
    dataTest: 'settings-modal-close-btn',
    mode: "secondary",
    onClick: resetStateCloseModal,
    size: "small"
  }, "Cancel"), /*#__PURE__*/_react.default.createElement(_button.default, {
    dataTest: 'settings-modal-apply-btn',
    disabled: hasNotInteracted,
    onClick: () => {
      setHasClickApplyAndClose(true);
    },
    mode: hasClickedApplyAndClose ? 'success' : 'primary',
    size: "small"
  }, hasClickedApplyAndClose ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, "Changes applied", ' ', /*#__PURE__*/_react.default.createElement("span", {
    className: "success-check-mark"
  }, "\u2705")) : 'Save and apply'))))));
};
const mapStateToProps = state => ({
  flags: state.flags,
  showFeatureHints: state.showFeatureHints,
  isPrettyName: state.isPrettyName,
  showDatasetPreviews: state.userPreferences.showDatasetPreviews,
  visible: state.visible
});
exports.mapStateToProps = mapStateToProps;
const mapDispatchToProps = dispatch => ({
  showSettingsModal: value => {
    dispatch((0, _actions.toggleSettingsModal)(value));
  },
  getPreferences: () => {
    dispatch((0, _preferences.getPreferences)());
  },
  onToggleFlag: (name, value) => {
    dispatch((0, _actions.changeFlag)(name, value));
  },
  onToggleIsPrettyName: value => {
    dispatch((0, _actions.toggleIsPrettyName)(value));
  },
  onToggleShowFeatureHints: value => {
    dispatch((0, _actions.toggleShowFeatureHints)(value));
  },
  onToggleShowDatasetPreviews: value => {
    dispatch((0, _preferences.updateUserPreferences)({
      showDatasetPreviews: value
    }));
  }
});
exports.mapDispatchToProps = mapDispatchToProps;
var _default = exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(SettingsModal);