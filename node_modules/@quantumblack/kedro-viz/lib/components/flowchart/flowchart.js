"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapStateToProps = exports.mapDispatchToProps = exports.default = exports.chartSizeTestFallback = exports.FlowChart = void 0;
var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));
var _react = _interopRequireWildcard(require("react"));
var _reactRedux = require("react-redux");
var _classnames = _interopRequireDefault(require("classnames"));
var _d3Selection = require("d3-selection");
var _actions = require("../../actions");
var _modularPipelines = require("../../actions/modular-pipelines");
var _nodes = require("../../actions/nodes");
var _nodes2 = require("../../selectors/nodes");
var _edges = require("../../selectors/edges");
var _layout = require("../../selectors/layout");
var _layers = require("../../selectors/layers");
var _linkedNodes = require("../../selectors/linked-nodes");
var _metadata = require("../../selectors/metadata");
var _draw = require("./draw");
var _view = require("../../utils/view");
var _tooltip = _interopRequireDefault(require("../ui/tooltip"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Display a pipeline flowchart, mostly rendered with D3
 */
class FlowChart extends _react.Component {
  constructor(props) {
    super(props);
    /**
     * Handle window resize
     */
    this.handleWindowResize = () => {
      this.updateChartSize();
    };
    /**
     * Add viewBox on window print so that the SVG can be scaled to fit
     */
    this.handleBeforePrint = () => {
      const graphSize = this.props.graphSize;
      const width = graphSize.width + graphSize.marginx * 2;
      const height = graphSize.height + graphSize.marginy * 2;
      this.el.svg.attr('viewBox', "0 0 ".concat(width, " ").concat(height));
    };
    /**
     * Remove viewBox once printing is done
     */
    this.handleAfterPrint = () => {
      this.el.svg.attr('viewBox', null);
    };
    /**
     * Returns parameter count when there are more
     * than one parameters and parameter name if there's a single parameter
     * @param {Array} parameterNames
     * @returns {String}
     */
    this.getHoveredParameterLabel = parameterNames => parameterNames.length > 1 ? "Parameters:".concat(parameterNames.length) : parameterNames[0];
    /**
     * Enable a node's focus state and highlight linked nodes
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    this.handleNodeClick = (event, node) => {
      const {
        type,
        id
      } = node;
      const {
        onClickToExpandModularPipeline,
        displayMetadataPanel,
        onLoadNodeData,
        toSelectedNode,
        onToggleNodeClicked
      } = this.props;
      if (type === 'modularPipeline') {
        onClickToExpandModularPipeline(id);
      } else {
        displayMetadataPanel ? onLoadNodeData(id) : onToggleNodeClicked(id);
        toSelectedNode(node);
      }
      event.stopPropagation();
    };
    /**
     * Remove a node's focus state and dim linked nodes
     */
    this.handleChartClick = () => {
      if (this.props.clickedNode) {
        this.props.onLoadNodeData(null);
        // To reset URL to current active pipeline when click outside of a node on flowchart
        this.props.toSelectedPipeline();
      }
    };
    /**
     * Enable a node's active state, show tooltip, and highlight linked nodes
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    this.handleNodeMouseOver = (event, node) => {
      this.props.onToggleNodeHovered(node.id);
      node && this.showTooltip(event, node.fullName);
    };
    /**
     * Enable a layer's active state when hovering it, update labelName's active className accordingly
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    this.handleLayerMouseOver = (event, node) => {
      if (node) {
        this.setState({
          activeLayer: node.name
        });
      }
      const {
        activeLayer
      } = this.state;
      const layerName = document.querySelector("[data-id=\"layer-label--".concat(node.name, "\"]"));
      if (activeLayer && layerName) {
        layerName.classList.add('pipeline-layer-name--active');
      }
    };
    /**
     * Remove the current labelName's active className when not hovering, and update layer's active state accordingly
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    this.handleLayerMouseOut = (event, node) => {
      const {
        activeLayer
      } = this.state;
      const layerName = document.querySelector("[data-id=\"layer-label--".concat(node.name, "\"]"));
      if (activeLayer && layerName) {
        layerName.classList.remove('pipeline-layer-name--active');
      }
      if (node) {
        this.setState({
          activeLayer: undefined
        });
      }
    };
    /**
     * Shows tooltip when the parameter indicator is hovered on
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    this.handleParamsIndicatorMouseOver = (event, node) => {
      const parameterNames = this.props.nodesWithInputParams[node.id];
      if (parameterNames) {
        const label = this.getHoveredParameterLabel(parameterNames);
        this.showTooltip(event, label);
      }
      event.stopPropagation();
    };
    /**
     * Remove a node's active state, hide tooltip, and dim linked nodes
     * @param {Object} node Datum for a single node
     */
    this.handleNodeMouseOut = () => {
      this.props.onToggleNodeHovered(null);
      this.hideTooltip();
    };
    /**
     * Handle keydown event when a node is focused
     * @param {Object} event Event object
     * @param {Object} node Datum for a single node
     */
    this.handleNodeKeyDown = (event, node) => {
      const ENTER = 13;
      const ESCAPE = 27;
      if (event.keyCode === ENTER) {
        this.handleNodeClick(event, node);
      }
      if (event.keyCode === ESCAPE) {
        this.handleChartClick();
        this.handleNodeMouseOut();
      }
    };
    this.state = {
      tooltip: {
        visible: false
      },
      activeLayer: undefined
    };
    this.onViewChange = this.onViewChange.bind(this);
    this.onViewChangeEnd = this.onViewChangeEnd.bind(this);
    this.containerRef = /*#__PURE__*/_react.default.createRef();
    this.svgRef = /*#__PURE__*/_react.default.createRef();
    this.wrapperRef = /*#__PURE__*/_react.default.createRef();
    this.edgesRef = /*#__PURE__*/_react.default.createRef();
    this.nodesRef = /*#__PURE__*/_react.default.createRef();
    this.layersRef = /*#__PURE__*/_react.default.createRef();
    this.layerNamesRef = /*#__PURE__*/_react.default.createRef();
    this.DURATION = 700;
    this.MARGIN = 500;
    this.MIN_SCALE = 0.8;
    this.MAX_SCALE = 2;
  }
  componentDidMount() {
    this.selectD3Elements();
    this.updateChartSize();
    this.view = (0, _view.viewing)({
      container: this.svgRef,
      wrapper: this.wrapperRef,
      onViewChanged: this.onViewChange,
      onViewEnd: this.onViewChangeEnd
    });
    this.updateViewExtents();
    this.addGlobalEventListeners();
    this.update();
    if (this.props.tooltip) {
      this.showTooltip(null, null, this.props.tooltip);
    } else {
      this.hideTooltip();
    }
  }
  componentWillUnmount() {
    this.removeGlobalEventListeners();
  }
  componentDidUpdate(prevProps) {
    this.update(prevProps);
  }

  /**
   * Updates drawing and zoom if props have changed
   */
  update() {
    var _this = this;
    let prevProps = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    const {
      chartZoom
    } = this.props;
    const changed = function () {
      for (var _len = arguments.length, names = new Array(_len), _key = 0; _key < _len; _key++) {
        names[_key] = arguments[_key];
      }
      return _this.changed(names, prevProps, _this.props);
    };
    const preventZoom = this.props.visibleMetaSidebar;
    if (changed('visibleSidebar', 'visibleCode', 'visibleMetaSidebar')) {
      this.updateChartSize();
    }
    if (changed('layers', 'chartSize')) {
      _draw.drawLayers.call(this);
      _draw.drawLayerNames.call(this);
    }
    if (changed('edges', 'clickedNode', 'linkedNodes', 'focusMode', 'inputOutputDataEdges')) {
      _draw.drawEdges.call(this, changed);
    }
    if (changed('nodes', 'clickedNode', 'linkedNodes', 'nodeTypeDisabled', 'nodeActive', 'nodeSelected', 'hoveredParameters', 'nodesWithInputParams', 'focusMode', 'inputOutputDataNodes', 'hoveredFocusMode')) {
      _draw.drawNodes.call(this, changed);
    }
    if (changed('edges', 'nodes', 'layers', 'chartSize', 'clickedNode')) {
      // Don't zoom out when the metadata or code panels are opened or closed
      if (prevProps.visibleMetaSidebar !== this.props.visibleMetaSidebar) {
        _draw.drawNodes.call(this, changed);
        _draw.drawEdges.call(this, changed);
        return;
      }
      if (prevProps.visibleCode !== this.props.visibleCode) {
        if (!this.props.visibleMetaSidebar) {
          _draw.drawNodes.call(this, changed);
          _draw.drawEdges.call(this, changed);
          return;
        }
      }
      this.resetView(preventZoom);
    } else {
      this.onChartZoomChanged(chartZoom);
    }
  }

  /**
   * Returns true if any of the given props are different between given objects.
   * Only shallow changes are detected.
   */
  changed(props, objectA, objectB) {
    return objectA && objectB && props.some(prop => objectA[prop] !== objectB[prop]);
  }

  /**
   * Create D3 element selectors
   */
  selectD3Elements() {
    this.el = {
      svg: (0, _d3Selection.select)(this.svgRef.current),
      wrapper: (0, _d3Selection.select)(this.wrapperRef.current),
      edgeGroup: (0, _d3Selection.select)(this.edgesRef.current),
      nodeGroup: (0, _d3Selection.select)(this.nodesRef.current),
      layerGroup: (0, _d3Selection.select)(this.layersRef.current),
      layerNameGroup: (0, _d3Selection.select)(this.layerNamesRef.current)
    };
  }

  /**
   * Update the chart size in state from chart container bounds.
   * This is emulated in tests with a constant fixed size.
   */
  updateChartSize() {
    if (typeof jest !== 'undefined') {
      // Emulate chart size for tests
      this.props.onUpdateChartSize(chartSizeTestFallback);
    } else {
      // Use container bounds
      this.props.onUpdateChartSize(this.containerRef.current.getBoundingClientRect());
    }
  }

  /**
   * Add window event listeners on mount
   */
  addGlobalEventListeners() {
    // Add ResizeObserver to listen for any changes in the container's width/height
    // (with event listener fallback)
    if (window.ResizeObserver) {
      this.resizeObserver = this.resizeObserver || new window.ResizeObserver(this.handleWindowResize);
      this.resizeObserver.observe(this.containerRef.current);
    } else {
      window.addEventListener('resize', this.handleWindowResize);
    }
    // Print event listeners
    window.addEventListener('beforeprint', this.handleBeforePrint);
    window.addEventListener('afterprint', this.handleAfterPrint);
  }

  /**
   * Remove window event listeners on unmount
   */
  removeGlobalEventListeners() {
    // ResizeObserver
    if (window.ResizeObserver) {
      this.resizeObserver.unobserve(this.containerRef.current);
    } else {
      window.removeEventListener('resize', this.handleWindowResize);
    }
    // Print event listeners
    window.removeEventListener('beforeprint', this.handleBeforePrint);
    window.removeEventListener('afterprint', this.handleAfterPrint);
  }
  /**
   * On every frame of every view transform change (from reset, pan, zoom etc.)
   * @param {Object} transform The current view transform
   */
  onViewChange(transform) {
    const {
      k: scale,
      x,
      y
    } = transform;

    // Apply animating class to zoom wrapper
    this.el.wrapper.classed('pipeline-flowchart__zoom-wrapper--animating', true);

    // Update layer label y positions
    if (this.el.layerNames) {
      this.el.layerNames.style('transform', d => {
        const updateY = y + (d.y + d.height / 2) * scale;
        return "translateY(".concat(updateY, "px)");
      });
    }

    // Hide the tooltip so it doesn't get misaligned to its node
    this.hideTooltip();

    // Update extents
    this.updateViewExtents(transform);
    const extents = (0, _view.getViewExtents)(this.view);

    // Share the applied zoom state with other components
    this.props.onUpdateZoom({
      scale,
      x,
      y,
      applied: true,
      transition: false,
      relative: false,
      minScale: extents.scale.minK,
      maxScale: extents.scale.maxK
    });
  }

  /**
   * Called when the view changes have ended (i.e. after transition ends)
   */
  onViewChangeEnd() {
    this.el.wrapper.classed('pipeline-flowchart__zoom-wrapper--animating', false);
  }

  /**
   * Updates view extents based on the current view transform.
   * Offsets the extents considering any open sidebars.
   * Allows additional margin for user panning within limits.
   * Zoom scale is limited to a practical range for usability.
   * @param {?Object} transform Current transform override
   */
  updateViewExtents(transform) {
    const {
      k: scale
    } = transform || (0, _view.getViewTransform)(this.view);
    const {
      sidebarWidth = 0,
      metaSidebarWidth = 0,
      codeSidebarWidth = 0,
      width: chartWidth = 0,
      height: chartHeight = 0
    } = this.props.chartSize;
    const {
      width: graphWidth = 0,
      height: graphHeight = 0
    } = this.props.graphSize;
    const leftSidebarOffset = sidebarWidth / scale;
    const rightSidebarOffset = (metaSidebarWidth + codeSidebarWidth) / scale;
    const margin = this.MARGIN;

    // Find the relative minimum scale to fit whole graph
    const minScale = Math.min(chartWidth / (graphWidth || 1), chartHeight / (graphHeight || 1));
    (0, _view.setViewExtents)(this.view, {
      translate: {
        minX: -leftSidebarOffset - margin,
        maxX: graphWidth + margin + rightSidebarOffset,
        minY: -margin,
        maxY: graphHeight + margin
      },
      scale: {
        minK: this.MIN_SCALE * minScale,
        maxK: this.MAX_SCALE
      }
    });
  }

  /**
   * Applies the given zoom state as necessary
   * @param {Object} chartZoom The new zoom state
   */
  onChartZoomChanged(chartZoom) {
    // No change if already applied (e.g. was an internal update)
    if (chartZoom.applied) {
      return;
    }

    // Apply reset if it was requested
    if (chartZoom.reset === true) {
      this.resetView(true);
      return;
    }

    // Set the view while respecting extents
    (0, _view.setViewTransform)(this.view, {
      x: chartZoom.x,
      y: chartZoom.y,
      k: chartZoom.scale
    }, chartZoom.transition ? this.DURATION * 0.3 : 0, chartZoom.relative);
  }

  /**
   * Zoom and scale to fit graph and any selected node in view
   */
  resetView(preventZoom) {
    const {
      chartSize,
      graphSize,
      clickedNode,
      nodes
    } = this.props;
    const {
      width: chartWidth,
      height: chartHeight
    } = chartSize;
    const {
      width: graphWidth,
      height: graphHeight
    } = graphSize;

    // Skip if chart or graph is not ready yet
    if (!chartWidth || !graphWidth) {
      return;
    }

    // Sidebar offset
    const offset = {
      x: chartSize.sidebarWidth,
      y: 0
    };

    // Use the selected node as focus point
    const focus = clickedNode ? nodes.find(node => node.id === clickedNode) : null;

    // Find a transform that fits everything in view
    const transform = (0, _view.viewTransformToFit)({
      offset,
      focus,
      viewWidth: chartWidth,
      viewHeight: chartHeight,
      objectWidth: graphWidth,
      objectHeight: graphHeight,
      minScaleX: 0.2,
      minScaleFocus: this.props.visibleMetaSidebar ? this.props.chartZoom.scale : 0.1,
      focusOffset: 0,
      preventZoom
    });

    // Detect first transform
    const isFirstTransform = (0, _view.isOrigin)((0, _view.getViewTransform)(this.view));

    // Apply transform ignoring extents
    (0, _view.setViewTransformExact)(this.view, transform, isFirstTransform ? 0 : this.DURATION, false);
  }
  /**
   * Show, fill and and position the tooltip
   * @param {Object} event Event object
   * @param {Object} text Text to show on the tooltip
   * @param {?Object} options Options for the tooltip if required
   */
  showTooltip(event, text) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    this.setState({
      tooltip: {
        targetRect: event && event.target.getBoundingClientRect(),
        text: text,
        visible: true,
        ...options
      }
    });
  }

  /**
   * Hide the tooltip
   */
  hideTooltip() {
    if (this.state.tooltip.visible) {
      this.setState({
        tooltip: {
          ...this.state.tooltip,
          visible: false
        }
      });
    }
  }

  /**
   * Render React elements
   */
  render() {
    const {
      chartSize,
      layers,
      visibleGraph,
      displayGlobalNavigation,
      displaySidebar
    } = this.props;
    const {
      outerWidth = 0,
      outerHeight = 0
    } = chartSize;
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "pipeline-flowchart kedro",
      ref: this.containerRef,
      onClick: this.handleChartClick
    }, /*#__PURE__*/_react.default.createElement("svg", {
      id: "pipeline-graph",
      className: "pipeline-flowchart__graph",
      width: outerWidth,
      height: outerHeight,
      ref: this.svgRef
    }, /*#__PURE__*/_react.default.createElement("g", {
      id: "zoom-wrapper",
      className: (0, _classnames.default)('pipeline-zoom-wrapper', {
        'pipeline-zoom-wrapper--hidden': !visibleGraph
      }),
      ref: this.wrapperRef
    }, /*#__PURE__*/_react.default.createElement("defs", null, ['arrowhead', 'arrowhead--input', 'arrowhead--accent--input', 'arrowhead--accent'].map(id => /*#__PURE__*/_react.default.createElement("marker", {
      id: "pipeline-".concat(id),
      key: id,
      className: "pipeline-flowchart__".concat(id),
      viewBox: "0 0 10 10",
      refX: "7",
      refY: "5",
      markerUnits: "strokeWidth",
      markerWidth: "8",
      markerHeight: "6",
      orient: "auto"
    }, /*#__PURE__*/_react.default.createElement("path", {
      d: "M 0 0 L 10 5 L 0 10 L 4 5 z"
    })))), /*#__PURE__*/_react.default.createElement("g", {
      className: "pipeline-flowchart__layers",
      ref: this.layersRef
    }), /*#__PURE__*/_react.default.createElement("g", {
      className: "pipeline-flowchart__edges",
      ref: this.edgesRef
    }), /*#__PURE__*/_react.default.createElement("g", {
      id: "nodes",
      className: "pipeline-flowchart__nodes",
      ref: this.nodesRef
    }))), /*#__PURE__*/_react.default.createElement("ul", {
      className: (0, _classnames.default)('pipeline-flowchart__layer-names', {
        'pipeline-flowchart__layer-names--visible': layers.length,
        'pipeline-flowchart__layer-names--no-global-toolbar': !displayGlobalNavigation,
        'pipeline-flowchart__layer-names--no-sidebar': !displaySidebar
      }),
      ref: this.layerNamesRef
    }), /*#__PURE__*/_react.default.createElement(_tooltip.default, (0, _extends2.default)({
      chartSize: chartSize
    }, this.state.tooltip, {
      style: {
        fontSize: '1.5em'
      }
    })));
  }
}

// Fixed chart size used in tests
exports.FlowChart = FlowChart;
const chartSizeTestFallback = exports.chartSizeTestFallback = {
  left: 0,
  top: 0,
  right: 1280,
  bottom: 1024,
  width: 1280,
  height: 1024
};

// Maintain a single reference to support change detection
const emptyEdges = [];
const emptyNodes = [];
const emptyGraphSize = {};
const mapStateToProps = (state, ownProps) => ({
  clickedNode: state.node.clicked,
  chartSize: (0, _layout.getChartSize)(state),
  chartZoom: (0, _layout.getChartZoom)(state),
  displayGlobalNavigation: state.display.globalNavigation,
  displaySidebar: state.display.sidebar,
  displayMetadataPanel: state.display.metadataPanel,
  edges: state.graph.edges || emptyEdges,
  focusMode: state.visible.modularPipelineFocusMode,
  graphSize: state.graph.size || emptyGraphSize,
  hoveredParameters: state.hoveredParameters,
  hoveredFocusMode: state.hoveredFocusMode,
  layers: (0, _layers.getLayers)(state),
  linkedNodes: (0, _linkedNodes.getLinkedNodes)(state),
  nodes: state.graph.nodes || emptyNodes,
  nodeTypeDisabled: state.nodeType.disabled,
  nodeActive: (0, _nodes2.getNodeActive)(state),
  nodeSelected: (0, _nodes2.getNodeSelected)(state),
  nodesWithInputParams: (0, _nodes2.getNodesWithInputParams)(state),
  inputOutputDataNodes: (0, _nodes2.getInputOutputNodesForFocusedModularPipeline)(state),
  inputOutputDataEdges: (0, _edges.getInputOutputDataEdges)(state),
  visibleGraph: state.visible.graph,
  visibleSidebar: state.visible.sidebar,
  visibleCode: state.visible.code,
  visibleMetaSidebar: (0, _metadata.getVisibleMetaSidebar)(state),
  ...ownProps
});
exports.mapStateToProps = mapStateToProps;
const mapDispatchToProps = (dispatch, ownProps) => ({
  onClickToExpandModularPipeline: modularPipelineId => {
    dispatch((0, _modularPipelines.toggleSingleModularPipelineExpanded)(modularPipelineId));
  },
  onLoadNodeData: nodeClicked => {
    dispatch((0, _nodes.loadNodeData)(nodeClicked));
  },
  onToggleNodeClicked: id => {
    dispatch((0, _nodes.toggleNodeClicked)(id));
  },
  onToggleNodeHovered: nodeHovered => {
    dispatch((0, _nodes.toggleNodeHovered)(nodeHovered));
  },
  onUpdateChartSize: chartSize => {
    dispatch((0, _actions.updateChartSize)(chartSize));
  },
  onUpdateZoom: transform => {
    dispatch((0, _actions.updateZoom)(transform));
  },
  ...ownProps
});
exports.mapDispatchToProps = mapDispatchToProps;
var _default = exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(FlowChart);