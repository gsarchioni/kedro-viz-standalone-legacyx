"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _propTypes = _interopRequireDefault(require("prop-types"));
require("what-input");
var _fp = require("lodash/fp");
var _eventController = _interopRequireDefault(require("./event-controller.js"));
var _hooks = require("../../../utils/hooks");
var _dropdownRenderer = _interopRequireDefault(require("./dropdown-renderer"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const Dropdown = props => {
  const {
    children,
    defaultText = 'Please select...',
    disabled = false,
    haveSelectedValues = false,
    onApplyAndClose,
    onCancel,
    onChanged,
    onClosed,
    onOpened,
    showCancelApplyBtns,
    width = 160,
    placeholderText,
    dataTest
  } = props;

  /**
   * Format the selected option props for adding to state
   * @param {Object} props - Component props
   * @return {Object} Selected option object for use in the state
   */
  const _findSelectedOption = (0, _react.useCallback)(props => {
    const selectedOptionElement = _findSelectedOptionElement(props);

    // check children for a selected option
    if (selectedOptionElement) {
      const {
        id,
        primaryText,
        value
      } = selectedOptionElement.props;
      return {
        id,
        label: primaryText,
        value
      };
    }

    // otherwise, default to first
    return {
      id: null,
      label: null,
      value: null
    };
  }, []);

  /**
   * Find the selected option by traversing sections and MenuOptions
   * @param {Object} props - Component props (optional)
   * @return {Object} Selected option element
   */
  const _findSelectedOptionElement = props => {
    const children = _react.default.Children.toArray(props.children);
    if (!children.length) {
      return null;
    }

    // we may have an array of options
    // or an array of sections, containing options
    if (children[0].type === 'section') {
      return (0, _fp.flow)((0, _fp.map)(x => x.props.children), _fp.flatten, (0, _fp.find)(x => x.props.selected))(children);
    }
    return (0, _fp.find)(child => child.props.selected)(children);
  };
  const prevProps = (0, _hooks.usePrevious)(props);
  const [focusedOption, setFocusedOption] = (0, _react.useState)(null);
  const [haveClicked, setHaveClicked] = (0, _react.useState)(false); // tracker for detecting _handleLabelClicked
  const [selectedOption, setSelectedOption] = (0, _react.useState)(_findSelectedOption(props));
  const [open, setOpen] = (0, _react.useState)(false);
  const [selectedObject, setSelectedObject] = (0, _react.useState)(null); // this is to store the object that was passed from the handleOptionSelected event handler

  const dropdownRef = (0, _react.useRef)();
  const handleOptionSelectedRef = (0, _react.useRef)({
    open,
    selectedOption
  });
  const selectedObjRef = (0, _react.useRef)(selectedObject);
  const mounted = (0, _react.useRef)(false); // ref for detecting mounting of component

  (0, _react.useEffect)(() => {
    /**
     * Check whether new props contain updated children
     * @param {Object} nextProps - New component props
     * @return {Boolean} True if new children are different from current ones
     */
    const _childrenHaveChanged = nextProps => {
      const children = [props, nextProps].map(props => _react.default.Children.toArray(props.children));
      return !(0, _fp.isEqual)(...children);
    };
    if (!mounted.current) {
      // update mounted on componentDidMount
      mounted.current = true;
    } else if (prevProps && _childrenHaveChanged(prevProps)) {
      // triggers every time on componentDidUpdate
      setSelectedOption(_findSelectedOption(prevProps));
    }
  }, [_findSelectedOption, prevProps, props]);
  (0, _react.useEffect)(() => {
    if (haveClicked === true) {
      if (typeof onOpened === 'function' && open) {
        onOpened();
      } else if (typeof onClosed === 'function' && !open) {
        onClosed();
      }
      setHaveClicked(false);
    }
  }, [haveClicked, onOpened, onClosed, open]);

  // to be fired after state changes triggered by handleOptionSelected event handler
  (0, _react.useEffect)(() => {
    // This check is to ensure that only the changes in the handleOptionSelected event handler will trigger this effect
    if (selectedObjRef.current !== selectedObject) {
      if (!open && handleOptionSelectedRef.current.handleOptionSelectedRef !== selectedOption) {
        if (typeof onChanged === 'function') {
          onChanged(selectedObject);
        }
      }
      if (!open && typeof onClosed === 'function') {
        onClosed();
      }
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [selectedObject, selectedObjRef]);

  // Event to be fired on componentWillUnmount
  (0, _react.useEffect)(() => {
    return () => _eventController.default.removeBodyListeners();
  }, []);
  (0, _react.useEffect)(() => {
    // Focus either the button label or the active option.
    // This is so screen-readers will follow the active element
    const focusClass = focusedOption !== null ? '.menu-option--focused' : '.dropdown__label';
    dropdownRef.current.querySelector(focusClass).focus();
  }, [focusedOption]);
  (0, _react.useEffect)(() => {
    if (open) {
      document.addEventListener('click', _handleBodyClicked);
    }
    return () => document.removeEventListener('click', _handleBodyClicked);
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [open]);

  /**
   * Handler for closing a dropdown if a click occurred outside the dropdown.
   * @param {Object} e - event object
   */
  const _handleBodyClicked = e => {
    if (dropdownRef.current && !dropdownRef.current.contains(e.target) && open) {
      _handleClose();
    }
  };

  /**
   * Event handler which is fired when the label is clicked
   */
  const _handleLabelClicked = () => {
    // remove or add the event listeners for
    if (open) {
      _eventController.default.removeBodyListeners();
    } else {
      _eventController.default.addBodyListener(_handleBodyClicked);
    }
    // revert the state of open
    setOpen(!open);
    // set the click tracker to true to trigger the userEffect callback
    setHaveClicked(true);
    _focusLabel();
  };

  /**
   * Sort, filter and flatten the list of children to retrieve just the MenuOptions,
   * with any Sections removed.
   * @return {Object} A flat list of MenuOptions
   */
  const _getOptionsList = () => {
    /**
     * Recurse through sections to retrieve a list of all MenuOptions
     * @param  {Object} previous The Options array as of the previous iteration
     * @param  {Object} current  The current item (either a MenuOption or Section)
     * @return {Object}          The current state of the Options array
     */
    const getSectionChildren = (previous, current) => {
      if (current.props.primaryText) {
        // MenuOption: Add to list
        return previous.concat(current);
      }
      if (current.type === 'section') {
        // Section: Keep recursing
        return previous.concat(current.props.children.reduce(getSectionChildren, []));
      }
      return previous;
    };
    return _react.default.Children.toArray(props.children).reduce(getSectionChildren, []);
  };

  /**
   * Convenience method to return focus from an option to the label.
   * This is particularly useful for screen-readers and keyboard users.
   */
  const _focusLabel = () => {
    dropdownRef.current.querySelector('.dropdown__label').focus();
    setFocusedOption(null);
  };

  /**
   * When the focused option changes (e.g. via up/down keyboard controls),
   * update the focusedOption index state and select the new one
   * @param {Number} direction - The direction that focus is travelling through the list:
   * negative is up and positive is down.
   */
  const _handleFocusChange = direction => {
    let newFocusedOption = focusedOption;
    const optionsLength = _getOptionsList().length;
    if (focusedOption === null) {
      newFocusedOption = direction > 0 ? 0 : optionsLength - 1;
    } else {
      newFocusedOption += direction;
    }
    if (newFocusedOption >= optionsLength || newFocusedOption < 0) {
      newFocusedOption = null;
    }
    setFocusedOption(newFocusedOption);
  };

  /**
   * Event handler which is fired when a child item is selected
   */
  const _handleOptionSelected = obj => {
    const {
      label,
      id,
      value
    } = obj;
    setSelectedObject(obj);

    // detect if the selected item has changed
    const hasChanged = value !== selectedOption.value;
    if (hasChanged) {
      const newSelectedOption = {
        label,
        value,
        id
      };
      setOpen(false);
      setSelectedOption(newSelectedOption);
    } else {
      setOpen(false);
    }
    _focusLabel();
  };

  /**
   * Retrieve a reference to the dropdown DOM node (from the renderer component),
   * and assign it to a class-wide variable property.
   * @param {Object} el - The ref for the Dropdown container node
   */
  const _handleRef = el => {
    dropdownRef.current = el;
  };

  /**
   * API method to close the dropdown
   */
  const _handleClose = () => {
    setOpen(false);

    // remove event listener
    _eventController.default.removeBodyListeners();
  };
  return /*#__PURE__*/_react.default.createElement(_dropdownRenderer.default, {
    defaultText: defaultText,
    disabled: disabled,
    focusedOption: focusedOption,
    handleRef: _handleRef,
    haveSelectedValues: haveSelectedValues,
    placeholderText: placeholderText,
    onApplyAndClose: () => {
      setOpen(false);
      onApplyAndClose();
    },
    onCancel: () => {
      setOpen(false);
      onCancel();
    },
    onLabelClicked: _handleLabelClicked,
    onOptionSelected: _handleOptionSelected,
    onSelectChanged: _handleFocusChange,
    open: open,
    selectedOption: selectedOption,
    showCancelApplyBtns: showCancelApplyBtns,
    width: width,
    dataTest: dataTest
  }, children);
};
Dropdown.propTypes = {
  /**
   * Child items. The nodes which React will pass down, defined inside the DropdownRenderer tag
   */
  children: _propTypes.default.node.isRequired,
  /**
   * Default text to show in a closed unselected state
   */
  defaultText: _propTypes.default.string,
  /**
   * Whether to disable the dropdown
   */
  disabled: _propTypes.default.bool,
  /**
   * Whether user has selected any value from the dropdown
   */
  haveSelectedValues: _propTypes.default.bool,
  /**
   * Callback function to be excecuted when a Apply and Close button is clicked
   */
  onApplyAndClose: _propTypes.default.func,
  /**
   * Callback function to be excecuted when a Cancel button is clicked
   */
  onCancel: _propTypes.default.func,
  /**
   * Callback function to be executed when a menu item is clicked, other than the one currently selected.
   */
  onChanged: _propTypes.default.func,
  /**
   * Callback to be executed after menu opens
   */
  onOpened: _propTypes.default.func,
  /**
   * Callback to be executed after menu closed
   */
  onClosed: _propTypes.default.func,
  /**
   * The width for the component. Both the label and options are the same width
   */
  width: _propTypes.default.number,
  /**
   * Placeholder text when value from dropdown is not selected
   */
  placeholderText: _propTypes.default.string
};
var _default = exports.default = Dropdown;