"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapStateToProps = exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactRouterDom = require("react-router-dom");
var _reactTransitionGroup = require("react-transition-group");
var _utils = require("../../apollo/utils");
var _reactRedux = require("react-redux");
var _queries = require("../../apollo/queries");
var _button = _interopRequireDefault(require("../ui/button"));
var _details = _interopRequireDefault(require("../experiment-tracking/details"));
var _sidebar = _interopRequireDefault(require("../sidebar"));
var _hoverStateContext = require("../experiment-tracking/utils/hover-state-context");
var _useGeneratePathname = require("../../utils/hooks/use-generate-pathname");
var _config = require("../../config");
var _matchPath = require("../../utils/match-path");
var _utils2 = require("../../utils");
var _helpers = require("../../store/helpers");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const MAX_NUMBER_COMPARISONS = 2; // 0-based, so three.

const defaultStyle = {
  opacity: 0,
  transition: "opacity .5s ease-in-out"
};
const transitionStyles = {
  entering: {
    opacity: 1
  },
  entered: {
    opacity: 1
  },
  exiting: {
    opacity: 0
  },
  exited: {
    opacity: 0
  }
};
const ExperimentWrapper = _ref => {
  let {
    theme,
    runsMetadata
  } = _ref;
  const [disableRunSelection, setDisableRunSelection] = (0, _react.useState)(false);
  const [enableShowChanges, setEnableShowChanges] = (0, _react.useState)(true);
  const [isSidebarVisible, setIsSidebarVisible] = (0, _react.useState)(true);
  const [pinnedRun, setPinnedRun] = (0, _react.useState)();
  const [selectedRunData, setSelectedRunData] = (0, _react.useState)(null);
  const [showRunDetailsModal, setShowRunDetailsModal] = (0, _react.useState)(false);
  const [showRunExportModal, setShowRunExportModal] = (0, _react.useState)(false);
  const [showRunPlotsModal, setShowRunPlotsModal] = (0, _react.useState)(false);
  const [newRunAdded, setNewRunAdded] = (0, _react.useState)(false);
  const [isDisplayingMetrics, setIsDisplayingMetrics] = (0, _react.useState)(false);
  const [enableComparisonView, setEnableComparisonView] = (0, _react.useState)(false);
  const [selectedRunIds, setSelectedRunIds] = (0, _react.useState)([]);
  const [activeTab, setActiveTab] = (0, _react.useState)(_config.tabLabels[0]);
  const [errorMessage, setErrorMessage] = (0, _react.useState)({});
  const [invalidUrl, setInvalidUrl] = (0, _react.useState)(false);
  const [usedNavigationBtn, setUsedNavigationBtn] = (0, _react.useState)(false);
  const [isKedroDatasetsCompatible, setIsKedroDatasetsCompatible] = (0, _react.useState)(false);
  const {
    pathname,
    search
  } = (0, _reactRouterDom.useLocation)();
  const searchParams = new URLSearchParams(search);
  const {
    matchedExperimentTrackingMainPage,
    matchedSelectedView,
    matchedSelectedRuns
  } = (0, _matchPath.findMatchedPath)(pathname, search);
  const {
    toExperimentTrackingPath,
    toSelectedRunsPath
  } = (0, _useGeneratePathname.useGeneratePathnameForExperimentTracking)();

  // Fetch all runs.
  const {
    data,
    loading
  } = (0, _utils.useApolloQuery)(_queries.GET_RUNS);

  // Fetch all data for selected runs.
  const {
    data: {
      runMetadata = [],
      plots = [],
      metrics = [],
      JSONData = []
    } = [],
    error: runDataError,
    loading: isRunDataLoading
  } = (0, _utils.useApolloQuery)(_queries.GET_RUN_DATA, {
    skip: selectedRunIds.length === 0,
    variables: {
      runIds: selectedRunIds,
      showDiff: true
    }
  });
  let runTrackingData = {};
  if (plots.length > 0) {
    runTrackingData['Plots'] = plots;
  } else {
    runTrackingData['Plots'] = [];
  }
  if (metrics.length > 0) {
    runTrackingData['Metrics'] = metrics;
  }
  if (JSONData.length > 0) {
    runTrackingData['JSON Data'] = JSONData;
  }
  const onRunSelection = id => {
    if (enableComparisonView) {
      if (selectedRunIds.includes(id)) {
        if (selectedRunIds.length === 1) {
          return;
        }
        const selectedIds = selectedRunIds.filter(run => run !== id);
        setSelectedRunIds(selectedIds);
        toSelectedRunsPath(selectedIds, activeTab, enableComparisonView);
        setNewRunAdded(false);
      } else {
        setSelectedRunIds([...selectedRunIds, id]);
        setNewRunAdded(true);
        toSelectedRunsPath([...selectedRunIds, id], activeTab, enableComparisonView);
      }
    } else {
      if (selectedRunIds.includes(id)) {
        return;
      } else {
        setSelectedRunIds([id]);
        toSelectedRunsPath([id], activeTab, enableComparisonView);
      }
    }
  };
  const onToggleComparisonView = () => {
    setEnableComparisonView(!enableComparisonView);
    if (selectedRunIds.length === 1) {
      toSelectedRunsPath(selectedRunIds.slice(0, 1), activeTab, !enableComparisonView);
    }
    if (enableComparisonView && selectedRunIds.length > 1) {
      setSelectedRunIds(selectedRunIds.slice(0, 1));
      toSelectedRunsPath(selectedRunIds.slice(0, 1), activeTab, !enableComparisonView);
    }
  };
  const onTabChangeHandler = tab => {
    setActiveTab(tab);
    toSelectedRunsPath(selectedRunIds, tab, enableComparisonView);
  };
  const redirectToSelectedRuns = () => {
    const runIds = searchParams.get(_config.params.run).split(',');
    const allRunIds = data === null || data === void 0 ? void 0 : data.runsList.map(run => run.id);
    const notFoundIds = runIds.find(id => !(allRunIds !== null && allRunIds !== void 0 && allRunIds.includes(id)));
    if (notFoundIds) {
      setErrorMessage(_config.errorMessages.runIds);
      setInvalidUrl(true);
    } else {
      const isComparison = runIds.length > 1 ? true : searchParams.get(_config.params.comparisonMode) === 'true';
      setSelectedRunIds(runIds);
      setEnableComparisonView(isComparison);
      if (_config.tabLabels.includes(searchParams.get(_config.params.view))) {
        setActiveTab(searchParams.get(_config.params.view));
      }
    }
  };
  const redirectToSelectedView = () => {
    const latestRun = data.runsList.map(run => run.id).slice(0, 1);
    setSelectedRunIds(latestRun);
    setEnableComparisonView(false);
    if (_config.tabLabels.includes(searchParams.get(_config.params.view))) {
      setActiveTab(searchParams.get(_config.params.view));
    }
  };
  const handlePopState = (0, _react.useCallback)(() => {
    setUsedNavigationBtn(usedNavigationBtn => !usedNavigationBtn);
  }, []);
  (0, _react.useEffect)(() => {
    async function fetchPackageCompatibility() {
      try {
        const request = await (0, _utils2.fetchPackageCompatibilities)();
        const response = await request.json();
        if (request.ok) {
          const kedroDatasetsPackage = response.find(pckg => pckg.package_name === _config.PACKAGE_KEDRO_DATASETS);
          setIsKedroDatasetsCompatible(kedroDatasetsPackage.is_compatible);
        }
      } catch (error) {
        console.error('package-compatibilities fetch error: ', error);
      }
    }
    fetchPackageCompatibility();
  }, []);
  (0, _react.useEffect)(() => {
    const showGoBackBtnFromStorage = (0, _helpers.loadLocalStorage)(_config.localStorageFlowchartLink).showGoBackBtn;
    if (showGoBackBtnFromStorage) {
      (0, _helpers.saveLocalStorage)(_config.localStorageFlowchartLink, _config.linkToFlowchartInitialVal);
    }
    window.addEventListener('popstate', handlePopState);
    return () => {
      window.removeEventListener('popstate', handlePopState);
    };
  }, [handlePopState]);
  (0, _react.useEffect)(() => {
    if (data) {
      /**
       * To display a generic error message when the URL is not matched any path at all
       */
      if (!matchedExperimentTrackingMainPage && !matchedSelectedRuns && !matchedSelectedView) {
        setErrorMessage(_config.errorMessages.experimentTracking);
        setInvalidUrl(true);
      }
      if (matchedSelectedRuns) {
        redirectToSelectedRuns();
      }

      /**
       * This is for when there's only view= is defined in the URL, without any run_ids
       * it should re-direct to the latest run
       */
      if (matchedSelectedView) {
        redirectToSelectedView();
      }
    }
    if (usedNavigationBtn) {
      setUsedNavigationBtn(false);
    }

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [data, usedNavigationBtn]);
  (0, _react.useEffect)(() => {
    if (selectedRunIds.length > MAX_NUMBER_COMPARISONS) {
      setDisableRunSelection(true);
    } else {
      setDisableRunSelection(false);
    }
  }, [selectedRunIds]);
  (0, _react.useEffect)(() => {
    /**
     * If we return runs and aren't in comparison view, set a single selected
     * run data object for use in the ExperimentPrimaryToolbar component.
     */

    if ((data === null || data === void 0 ? void 0 : data.runsList.length) > 0 && !enableComparisonView) {
      const singleSelectedRunData = data.runsList.filter(run => {
        return run.id === selectedRunIds[0];
      })[0];
      setSelectedRunData(singleSelectedRunData);
    }
  }, [data, enableComparisonView, selectedRunIds]);
  (0, _react.useEffect)(() => {
    if (matchedExperimentTrackingMainPage && (data === null || data === void 0 ? void 0 : data.runsList.length) > 0 && selectedRunIds.length === 0) {
      /**
       * If we return to default main page and don't yet have a selected run, set the first one
       * as the default, with precedence given to runs that are bookmarked.
       */
      const bookmarkedRuns = data.runsList.filter(run => {
        var _runsMetadata$run$id;
        return ((_runsMetadata$run$id = runsMetadata[run.id]) === null || _runsMetadata$run$id === void 0 ? void 0 : _runsMetadata$run$id.bookmark) === true;
      });
      if (bookmarkedRuns.length > 0) {
        setSelectedRunIds(bookmarkedRuns.map(run => run.id).slice(0, 1));
      } else {
        setSelectedRunIds(data.runsList.map(run => run.id).slice(0, 1));
      }
    }
  }, [data, selectedRunIds, matchedExperimentTrackingMainPage, runsMetadata]);
  (0, _react.useEffect)(() => {
    if (typeof pinnedRun === 'undefined' || !selectedRunIds.includes(pinnedRun)) {
      // Assign the first selected run as the first pinned run.
      setPinnedRun(selectedRunIds[0]);
    }
  }, [selectedRunIds, pinnedRun]);
  if (loading) {
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "experiment-wrapper"
    }, /*#__PURE__*/_react.default.createElement("p", {
      className: "experiment-wrapper__text"
    }, "Loading..."));
  }
  if (invalidUrl) {
    return /*#__PURE__*/_react.default.createElement("div", {
      className: "experiment-wrapper__error"
    }, /*#__PURE__*/_react.default.createElement("h2", {
      className: "experiment-wrapper__header"
    }, "Oops, this URL isn't valid"), /*#__PURE__*/_react.default.createElement("p", {
      className: "experiment-wrapper__text"
    }, "".concat(errorMessage, ".")), /*#__PURE__*/_react.default.createElement(_button.default, {
      onClick: () => {
        toExperimentTrackingPath();
        setInvalidUrl(false);
      }
    }, "Reset view"));
  } else {
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_hoverStateContext.HoverStateContextProvider, null, (data === null || data === void 0 ? void 0 : data.runsList.length) > 0 ? /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, /*#__PURE__*/_react.default.createElement(_sidebar.default, {
      disableRunSelection: disableRunSelection,
      enableComparisonView: enableComparisonView,
      enableShowChanges: enableShowChanges,
      isDisplayingMetrics: isDisplayingMetrics,
      isExperimentView: true,
      onRunSelection: onRunSelection,
      onToggleComparisonView: onToggleComparisonView,
      runsListData: data.runsList,
      selectedRunData: selectedRunData,
      selectedRunIds: selectedRunIds,
      setEnableShowChanges: setEnableShowChanges,
      setShowRunExportModal: setShowRunExportModal,
      setSidebarVisible: setIsSidebarVisible,
      showRunDetailsModal: setShowRunDetailsModal,
      sidebarVisible: isSidebarVisible
    }), /*#__PURE__*/_react.default.createElement(_reactTransitionGroup.Transition, {
      in: selectedRunIds.length > 0,
      timeout: 300
    }, state => /*#__PURE__*/_react.default.createElement("div", {
      style: {
        ...defaultStyle,
        ...transitionStyles[state]
      }
    }, selectedRunIds.length > 0 ? /*#__PURE__*/_react.default.createElement(_details.default, {
      activeTab: activeTab,
      enableComparisonView: enableComparisonView,
      enableShowChanges: enableShowChanges && selectedRunIds.length > 1,
      isKedroDatasetsCompatible: isKedroDatasetsCompatible,
      isRunDataLoading: isRunDataLoading,
      newRunAdded: newRunAdded,
      onRunSelection: onRunSelection,
      pinnedRun: pinnedRun,
      runDataError: runDataError,
      runMetadata: runMetadata,
      runTrackingData: runTrackingData,
      selectedRunIds: selectedRunIds,
      setActiveTab: onTabChangeHandler,
      setIsDisplayingMetrics: setIsDisplayingMetrics,
      setPinnedRun: setPinnedRun,
      setShowRunDetailsModal: setShowRunDetailsModal,
      setShowRunExportModal: setShowRunExportModal,
      setShowRunPlotsModal: setShowRunPlotsModal,
      showRunDetailsModal: showRunDetailsModal,
      showRunExportModal: showRunExportModal,
      showRunPlotsModal: showRunPlotsModal,
      sidebarVisible: isSidebarVisible,
      theme: theme
    }) : null))) : /*#__PURE__*/_react.default.createElement(_reactTransitionGroup.Transition, {
      in: (data === null || data === void 0 ? void 0 : data.runsList.length) <= 0,
      timeout: 300
    }, state => /*#__PURE__*/_react.default.createElement("div", {
      className: "experiment-wrapper",
      style: {
        ...defaultStyle,
        ...transitionStyles[state]
      }
    }, /*#__PURE__*/_react.default.createElement("h2", {
      className: "experiment-wrapper__header"
    }, "You don't have any experiments"), /*#__PURE__*/_react.default.createElement("p", {
      className: "experiment-wrapper__text"
    }, "Kedro can help you manage your experiments. Learn more how you can enable experiment tracking in your projects from our docs.", ' '), /*#__PURE__*/_react.default.createElement("a", {
      href: "https://docs.kedro.org/en/stable/visualisation/experiment_tracking.html",
      rel: "noreferrer",
      target: "_blank"
    }, /*#__PURE__*/_react.default.createElement(_button.default, null, "View docs"))))));
  }
};
const mapStateToProps = state => ({
  theme: state.theme,
  runsMetadata: state.runsMetadata
});
exports.mapStateToProps = mapStateToProps;
var _default = exports.default = (0, _reactRedux.connect)(mapStateToProps)(ExperimentWrapper);