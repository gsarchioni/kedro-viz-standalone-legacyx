"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUniqueValues = exports.ParallelCoordinates = void 0;
var _react = _interopRequireWildcard(require("react"));
var _classnames = _interopRequireDefault(require("classnames"));
var d3 = _interopRequireWildcard(require("d3"));
var _hoverStateContext = require("../utils/hover-state-context");
var _uuid = require("uuid");
var _tooltip = require("../tooltip/tooltip");
var _getTooltipPosition = require("../tooltip/get-tooltip-position");
var _dateUtils = require("../../../utils/date-utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const getUniqueValues = values => {
  return values.filter((value, i, self) => self.indexOf(value) === i).filter(value => value !== null).sort((a, b) => a - b);
};
exports.getUniqueValues = getUniqueValues;
const paddingTopBottom = 38;
const paddingLeftRight = 80;
const axisGapBuffer = 3;
const selectedMarkerRotate = [45, 0, 0];
const yAxis = {};
const yScales = {};
const ParallelCoordinates = _ref => {
  let {
    chartHeight,
    chartWidth,
    metricsData,
    selectedRuns,
    sidebarVisible
  } = _ref;
  const [hoveredMetricLabel, setHoveredMetricLabel] = (0, _react.useState)(null);
  const [showTooltip, setShowTooltip] = (0, _react.useState)(_tooltip.tooltipDefaultProps);
  const {
    hoveredElementId,
    setHoveredElementId
  } = (0, _react.useContext)(_hoverStateContext.HoverStateContext);
  const selectedMarkerShape = [d3.symbolSquare, d3.symbolCircle, d3.symbolTriangle];
  const graph = Object.entries(metricsData.metrics);
  const graphKeys = (0, _react.useMemo)(() => Object.keys(metricsData.metrics), [metricsData.metrics]);
  const data = Object.entries(metricsData.runs);
  const selectedData = data.filter(_ref2 => {
    let [key] = _ref2;
    return selectedRuns.includes(key);
  }).sort((a, b) => {
    // We need to sort the selected data to match the order of selectedRuns.
    // If we didn't, the highlighted runs would switch colors unnecessarily.
    return selectedRuns.indexOf(a[0]) - selectedRuns.indexOf(b[0]);
  });
  const hoveredValues = hoveredElementId && metricsData.runs[hoveredElementId];
  const xScale = d3.scalePoint().domain(graphKeys).range([paddingLeftRight, chartWidth - paddingLeftRight]);

  // For each metric, draw a y-scale
  graph.forEach(_ref3 => {
    let [key, value] = _ref3;
    yScales[key] = d3.scaleLinear().domain([d3.min(value), d3.max(value)]).range([chartHeight - paddingTopBottom * 2.15, paddingTopBottom + paddingTopBottom / axisGapBuffer]);
  });
  Object.entries(yScales).forEach(_ref4 => {
    let [key, value] = _ref4;
    yAxis[key] = d3.axisLeft(value).ticks(0).tickSizeOuter(0);
  });
  const lineGenerator = d3.line().defined(function (d) {
    return d !== null;
  });
  const linePath = function (d) {
    const points = d.map((x, i) => {
      if (x !== null) {
        return [xScale(graphKeys[i]), yScales[graphKeys[i]](x)];
      } else {
        return null;
      }
    });
    return lineGenerator(points);
  };
  const handleMouseOverMetric = (e, key) => {
    const runsCount = graph.find(each => each[0] === key)[1].length;
    const {
      x,
      y,
      direction
    } = (0, _getTooltipPosition.getTooltipPosition)(e, sidebarVisible);
    setHoveredMetricLabel(key);
    setShowTooltip({
      content: {
        label1: 'Metric name',
        value1: key,
        label2: 'Run count',
        value2: runsCount
      },
      direction,
      position: {
        x,
        y
      },
      visible: true
    });
  };
  const handleMouseOutMetric = () => {
    setHoveredMetricLabel(null);
    setShowTooltip(_tooltip.tooltipDefaultProps);
  };
  const handleMouseOverLine = (e, key) => {
    setHoveredElementId(key);
    if (e) {
      const parsedDate = new Date((0, _dateUtils.formatTimestamp)(key));
      const {
        x,
        y,
        direction
      } = (0, _getTooltipPosition.getTooltipPosition)(e, sidebarVisible);
      setShowTooltip({
        content: {
          label1: 'Run name',
          value1: key,
          label2: 'Date',
          value2: parsedDate.toLocaleDateString('default', {
            day: 'numeric',
            month: 'long',
            year: 'numeric'
          })
        },
        direction,
        position: {
          x,
          y
        },
        visible: true
      });
    }
  };
  const handleMouseOutLine = () => {
    setHoveredElementId(null);
    setShowTooltip(_tooltip.tooltipDefaultProps);
  };
  (0, _react.useEffect)(() => {
    d3.select(".run-line[id=\"".concat(hoveredElementId, "\"]")).raise();
  }, [hoveredElementId]);
  (0, _react.useEffect)(() => {
    d3.select(".metric-axis[id=\"".concat(hoveredMetricLabel, "\"]")).raise();
    d3.selectAll(".selected-runs").raise();
    d3.selectAll(".selected-runs > path").raise();
  }, [hoveredMetricLabel]);
  return /*#__PURE__*/_react.default.createElement("div", {
    className: "parallel-coordinates"
  }, /*#__PURE__*/_react.default.createElement(_tooltip.ExperimentTrackingTooltip, {
    content: showTooltip.content,
    direction: showTooltip.direction,
    position: showTooltip.position,
    visible: showTooltip.visible
  }), /*#__PURE__*/_react.default.createElement("svg", {
    preserveAspectRatio: "xMinYMin meet",
    viewBox: "0 0 ".concat(chartWidth, " ").concat(chartHeight),
    width: "100%"
  }, graphKeys.map(metricName => {
    const getYAxis = ref => {
      d3.select(ref).call(yAxis[metricName]).attr('id', metricName);
    };
    return /*#__PURE__*/_react.default.createElement("g", {
      className: (0, _classnames.default)('metric-axis', {
        'metric-axis--hovered': hoveredMetricLabel === metricName,
        'metric-axis--faded': hoveredMetricLabel && hoveredMetricLabel !== metricName
      }),
      key: "metric-axis--".concat(metricName),
      ref: getYAxis,
      transform: "translate(".concat(xScale(metricName), ", 0)"),
      y: paddingTopBottom / 2
    }, /*#__PURE__*/_react.default.createElement("text", {
      className: "headers",
      key: "metric-axis-text--".concat(metricName),
      onMouseOut: handleMouseOutMetric,
      onMouseOver: e => handleMouseOverMetric(e, metricName),
      textAnchor: "middle",
      y: paddingTopBottom / 2
    }, metricName.length > 20 ? '...' + metricName.slice(-20) : metricName));
  }), /*#__PURE__*/_react.default.createElement("g", {
    className: "run-lines"
  }, data.map((_ref5, i) => {
    let [runId, value] = _ref5;
    return /*#__PURE__*/_react.default.createElement("path", {
      className: (0, _classnames.default)('run-line', {
        'run-line--hovered': hoveredElementId === runId,
        'run-line--faded': hoveredElementId && hoveredElementId !== runId || hoveredMetricLabel
      }),
      d: linePath(value, i),
      id: runId,
      key: runId,
      onMouseLeave: handleMouseOutLine,
      onMouseOver: e => handleMouseOverLine(e, runId)
    });
  })), graph.map((_ref6, metricIndex) => {
    let [metricName, values] = _ref6;
    // To avoid rendering a tick more than once
    const uniqueValues = getUniqueValues(values);
    return /*#__PURE__*/_react.default.createElement("g", {
      className: "tick-values",
      id: metricName,
      key: (0, _uuid.v4)()
    }, uniqueValues.map(value => {
      // To ensure the hoveredValues are highlighted once per axis
      const highlightedValue = hoveredValues && hoveredValues.find((value, index) => index === metricIndex && value);
      const xScaleTickValue = isNaN(xScale(metricName)) ? 0 : xScale(metricName);
      const yScaleTickValue = isNaN(yScales[metricName](value)) ? 0 : yScales[metricName](value);
      return /*#__PURE__*/_react.default.createElement("text", {
        className: (0, _classnames.default)('text', {
          'text--hovered': hoveredMetricLabel === metricName || highlightedValue && highlightedValue === value,
          'text--faded': hoveredMetricLabel && hoveredMetricLabel !== metricName || highlightedValue && highlightedValue !== value
        }),
        key: (0, _uuid.v4)(),
        x: xScaleTickValue - 8,
        y: yScaleTickValue + 3,
        style: {
          textAnchor: 'end',
          transform: 'translate(-10,4)'
        }
      }, value === null || value === void 0 ? void 0 : value.toFixed(3));
    }));
  }), graph.map((_ref7, metricIndex) => {
    let [metricName, values] = _ref7;
    const sortedValues = getUniqueValues(values);
    return /*#__PURE__*/_react.default.createElement("g", {
      className: "tick-lines",
      id: metricName,
      key: "tick-lines--".concat(metricName)
    }, sortedValues.map(value => {
      // To ensure the hoveredValues are highlighted once per axis
      const highlightedValue = hoveredValues && hoveredValues.find((value, index) => index === metricIndex && value);
      const xScaleMetricName = isNaN(xScale(metricName)) ? 0 : xScale(metricName);
      const yScaleMetricName = isNaN(yScales[metricName](value)) ? 0 : yScales[metricName](value);
      if (value) {
        return /*#__PURE__*/_react.default.createElement("line", {
          className: (0, _classnames.default)('line', {
            'line--hovered': hoveredMetricLabel === metricName || highlightedValue && highlightedValue === value,
            'line--faded': hoveredMetricLabel && hoveredMetricLabel !== metricName || highlightedValue && highlightedValue !== value
          }),
          key: (0, _uuid.v4)(),
          x1: xScaleMetricName,
          x2: xScaleMetricName - 4,
          y1: yScaleMetricName,
          y2: yScaleMetricName
        });
      } else {
        return null;
      }
    }));
  }), /*#__PURE__*/_react.default.createElement("g", {
    className: "selected-runs"
  }, selectedData.map((_ref8, i) => {
    let [id, value] = _ref8;
    return /*#__PURE__*/_react.default.createElement("path", {
      className: (0, _classnames.default)({
        'run-line--selected-first': i === 0,
        'run-line--selected-second': i === 1,
        'run-line--selected-third': i === 2
      }),
      d: linePath(value, i),
      id: id,
      key: id
    });
  }), selectedData.map((_ref9, i) => {
    let [, values] = _ref9;
    return values.map((value, index) => {
      const transformX = xScale(graphKeys[index]);
      const transformY = yScales[graphKeys[index]](value);
      const rotate = selectedMarkerRotate[i];
      const xScaleGraphKey = isNaN(xScale(graphKeys[index])) ? 0 : xScale(graphKeys[index]);
      const yScaleGraphKey = isNaN(yScales[graphKeys[index]](value)) ? 0 : yScales[graphKeys[index]](value);
      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, {
        key: (0, _uuid.v4)()
      }, /*#__PURE__*/_react.default.createElement("path", {
        className: "marker-path--selected-".concat(i),
        d: "".concat(d3.symbol(selectedMarkerShape[i], 20)()),
        key: "marker-path--".concat(index),
        transform: "translate(".concat(transformX, ", ").concat(transformY, ") rotate(").concat(rotate, ")")
      }), /*#__PURE__*/_react.default.createElement("text", {
        className: "text",
        key: "marker-text--".concat(index),
        x: xScaleGraphKey - 8,
        y: yScaleGraphKey + 3,
        style: {
          textAnchor: 'end',
          transform: 'translate(-10,4)'
        }
      }, value === null || value === void 0 ? void 0 : value.toFixed(3)));
    });
  }))));
};
exports.ParallelCoordinates = ParallelCoordinates;