"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapStateToProps = exports.mapDispatchToProps = exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactRedux = require("react-redux");
var _classnames = _interopRequireDefault(require("classnames"));
var _searchUtils = require("../../../utils/search-utils");
var _dateUtils = require("../../../utils/date-utils");
var _bookmark = _interopRequireDefault(require("../../icons/bookmark"));
var _bookmarkStroke = _interopRequireDefault(require("../../icons/bookmark-stroke"));
var _hoverStateContext = require("../utils/hover-state-context");
var _actions = require("../../../actions");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/**
 * Display a card showing run info from an experiment
 * @param {Object} data High-level data from the run (id, etc.)
 */
const RunsListCard = _ref => {
  let {
    data,
    disableRunSelection = false,
    enableComparisonView = false,
    onRunSelection,
    selectedRunIds = [],
    searchValue,
    selectedIndex,
    runsMetadata,
    onToggleBookmark
  } = _ref;
  const {
    id,
    gitSha
  } = data;
  const {
    notes = '',
    title = id,
    bookmark = false
  } = runsMetadata[id] || {};
  const [active, setActive] = (0, _react.useState)(false);
  const humanReadableTime = (0, _dateUtils.toHumanReadableTime)(id);
  const {
    setHoveredElementId,
    hoveredElementId
  } = (0, _react.useContext)(_hoverStateContext.HoverStateContext);
  const isMatchSearchValue = text => searchValue ? (0, _searchUtils.textMatchesSearch)(text, searchValue) : false;
  const displayValue = value => isMatchSearchValue(value) ? (0, _searchUtils.getHighlightedText)(value, searchValue) : value;
  const isSearchValueInNotes = isMatchSearchValue(notes);
  const onRunsListCardClick = (id, e) => {
    /**
     * If we click the bookmark icon or the path HTML element within the SVG,
     * then update the bookmark boolean. If we didn't check for the path, the
     * user could hit a dead zone, and nothing would happen.
     */
    if (e.target.classList.contains('runs-list-card__bookmark') || e.target.tagName === 'path') {
      onToggleBookmark(!bookmark, id);
      return;
    }
    onRunSelection(id);
  };
  (0, _react.useEffect)(() => {
    setActive(selectedRunIds.includes(id));
  }, [id, selectedRunIds]);
  return /*#__PURE__*/_react.default.createElement("div", {
    className: (0, _classnames.default)('kedro', 'runs-list-card', {
      'runs-list-card--active': active,
      'runs-list-card--disabled': disableRunSelection && !active,
      'runs-list-card--hovered': hoveredElementId === id
    }),
    onClick: e => onRunsListCardClick(id, e),
    onMouseOver: () => setHoveredElementId(id),
    onMouseLeave: () => setHoveredElementId(null)
  }, enableComparisonView && /*#__PURE__*/_react.default.createElement("div", {
    className: (0, _classnames.default)('runs-list-card__checked', {
      'runs-list-card__checked--active': active,
      'runs-list-card__checked--comparing': enableComparisonView,
      'runs-list-card__checked--selected-first': selectedIndex === 0,
      'runs-list-card__checked--selected-second': selectedIndex === 1,
      'runs-list-card__checked--selected-third': selectedIndex === 2
    })
  }), /*#__PURE__*/_react.default.createElement("div", null, /*#__PURE__*/_react.default.createElement("div", {
    className: "runs-list-card__title",
    dangerouslySetInnerHTML: {
      __html: displayValue(title)
    }
  }), /*#__PURE__*/_react.default.createElement("div", {
    className: "runs-list-card__gitsha",
    dangerouslySetInnerHTML: {
      __html: displayValue(gitSha)
    }
  }), /*#__PURE__*/_react.default.createElement("div", {
    className: "runs-list-card__timestamp"
  }, humanReadableTime), isSearchValueInNotes && /*#__PURE__*/_react.default.createElement("div", {
    className: "runs-list-card__notes",
    dangerouslySetInnerHTML: {
      __html: "Notes:  <em>".concat(displayValue(notes), "</em>")
    }
  })), bookmark ? /*#__PURE__*/_react.default.createElement(_bookmark.default, {
    className: 'runs-list-card__bookmark runs-list-card__bookmark--solid'
  }) : /*#__PURE__*/_react.default.createElement(_bookmarkStroke.default, {
    className: 'runs-list-card__bookmark runs-list-card__bookmark--stroke'
  }));
};
const mapStateToProps = state => ({
  runsMetadata: state.runsMetadata
});
exports.mapStateToProps = mapStateToProps;
const mapDispatchToProps = dispatch => ({
  onToggleBookmark: (bookmark, runId) => {
    dispatch((0, _actions.toggleBookmark)(bookmark, runId));
  }
});
exports.mapDispatchToProps = mapDispatchToProps;
var _default = exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(RunsListCard);