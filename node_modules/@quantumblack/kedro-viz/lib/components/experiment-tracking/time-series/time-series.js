"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getSelectedOrderedData = exports.TimeSeries = void 0;
var _react = _interopRequireWildcard(require("react"));
var _classnames = _interopRequireDefault(require("classnames"));
var _dateUtils = require("../../../utils/date-utils");
var _hooks = require("../../../utils/hooks");
var _hoverStateContext = require("../utils/hover-state-context");
var _tooltip = require("../tooltip/tooltip");
var _getTooltipPosition = require("../tooltip/get-tooltip-position");
var d3 = _interopRequireWildcard(require("d3"));
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
const getSelectedOrderedData = (runData, selectedRuns) => {
  return runData.filter(_ref => {
    let [key, _] = _ref;
    return selectedRuns.includes(key);
  }).sort((a, b) => {
    // We need to sort the selected data to match the order of selectedRuns.
    // If we didn't, the highlighted runs would switch colors unnecessarily.
    return selectedRuns.indexOf(a[0]) - selectedRuns.indexOf(b[0]);
  }).map((_ref2, i) => {
    let [key, value] = _ref2;
    return [new Date((0, _dateUtils.formatTimestamp)(key)), value];
  });
};
exports.getSelectedOrderedData = getSelectedOrderedData;
const chartBuffer = 0.02;
const height = 150;
const margin = {
  top: 20,
  right: 10,
  bottom: 80,
  left: 35
};
const yScales = {};
const TimeSeries = _ref3 => {
  let {
    chartWidth,
    metricsData,
    selectedRuns,
    sidebarVisible
  } = _ref3;
  const previouslySelectedRuns = (0, _hooks.usePrevious)(selectedRuns);
  const [showTooltip, setShowTooltip] = (0, _react.useState)(_tooltip.tooltipDefaultProps);
  const [rangeSelection, setRangeSelection] = (0, _react.useState)(undefined);
  const {
    hoveredElementId,
    setHoveredElementId
  } = (0, _react.useContext)(_hoverStateContext.HoverStateContext);
  const defaultChartWidth = isNaN(chartWidth) ? 100 : chartWidth;
  const selectedMarkerRotate = [45, 0, 0];
  const selectedMarkerShape = [d3.symbolSquare, d3.symbolCircle, d3.symbolTriangle];
  const hoveredElementDate = hoveredElementId && new Date((0, _dateUtils.formatTimestamp)(hoveredElementId));
  const hoveredValues = hoveredElementId && metricsData.runs[hoveredElementId];
  const metricKeys = Object.keys(metricsData.metrics);
  const metricData = Object.entries(metricsData.metrics);
  const runKeys = Object.keys(metricsData.runs);
  const runData = Object.entries(metricsData.runs);
  const parsedData = runData.map(_ref4 => {
    let [key, value] = _ref4;
    return [new Date((0, _dateUtils.formatTimestamp)(key)), value];
  });
  const parsedDates = parsedData.map(_ref5 => {
    let [key, _] = _ref5;
    return key;
  });
  const diffDays = parseInt((d3.max(parsedDates) - d3.min(parsedDates)) / (1000 * 60 * 60 * 24), 10);
  const minDate = new Date(d3.min(parsedDates));
  minDate.setDate(minDate.getDate() - diffDays * chartBuffer);
  const maxDate = new Date(d3.max(parsedDates));
  maxDate.setDate(maxDate.getDate() + diffDays * chartBuffer);
  const selectedData = runData.filter(_ref6 => {
    let [key, _] = _ref6;
    return selectedRuns.includes(key);
  }).map((_ref7, i) => {
    let [key, value] = _ref7;
    return [new Date((0, _dateUtils.formatTimestamp)(key)), value];
  });
  metricData.map((_ref8, i) => {
    let [_, value] = _ref8;
    return yScales[i] = d3.scaleLinear().domain([Math.min(...value) - Math.min(...value) * chartBuffer, Math.max(...value) + Math.max(...value) * chartBuffer]).range([height, 0]);
  });
  const xScale = d3.scaleTime().domain([minDate, maxDate]).range([0, defaultChartWidth]);
  if (rangeSelection) {
    xScale.domain(rangeSelection);
  }
  const handleMouseOverLine = (e, key) => {
    setHoveredElementId(key);
    if (e) {
      const parsedDate = new Date((0, _dateUtils.formatTimestamp)(key));
      const {
        x,
        y,
        direction
      } = (0, _getTooltipPosition.getTooltipPosition)(e, sidebarVisible);
      setShowTooltip({
        content: {
          label1: 'Run name',
          value1: key,
          label2: 'Date',
          value2: parsedDate.toLocaleDateString('default', {
            day: 'numeric',
            month: 'long',
            year: 'numeric'
          })
        },
        direction,
        position: {
          x,
          y
        },
        visible: true
      });
    }
  };
  const handleMouseOutLine = () => {
    setHoveredElementId(null);
    setShowTooltip(_tooltip.tooltipDefaultProps);
  };
  (0, _react.useEffect)(() => {
    d3.selectAll("line[id=\"".concat(hoveredElementId, "\"]")).raise();
  }, [hoveredElementId]);
  if (previouslySelectedRuns !== selectedRuns) {
    if (rangeSelection) {
      setRangeSelection(undefined);
    }
  }
  return /*#__PURE__*/_react.default.createElement("div", {
    className: "time-series"
  }, /*#__PURE__*/_react.default.createElement(_tooltip.ExperimentTrackingTooltip, {
    content: showTooltip.content,
    direction: showTooltip.direction,
    position: showTooltip.position,
    visible: showTooltip.visible
  }), metricKeys.map((metricName, metricIndex) => {
    const metricValues = Object.values(metricsData.metrics)[metricIndex];
    const getXAxis = ref => {
      if (rangeSelection) {
        d3.select(ref).transition().duration(1000).call(d3.axisBottom(xScale).tickSizeOuter(0));
      } else {
        d3.select(ref).call(d3.axisBottom(xScale).tickSizeOuter(0));
      }
    };
    const getYAxis = ref => {
      d3.select(ref).call(d3.axisLeft(yScales[metricIndex]).tickSizeOuter(0).tickFormat(x => "".concat(x.toFixed(2))));
    };
    const lineGenerator = d3.line().defined(function (d) {
      return d !== null;
    });
    const linePath = data => {
      let points = data.map((x, i) => {
        if (x !== null) {
          return [xScale(parsedDates[i]), yScales[metricIndex](x)];
        } else {
          return null;
        }
      });
      return lineGenerator(points);
    };
    const trendLinePath = data => {
      let points = data.map(_ref9 => {
        let [key, value] = _ref9;
        if (value !== null) {
          return [xScale(key), yScales[metricIndex](value[metricIndex])];
        } else {
          return null;
        }
      });
      return d3.line()(points);
    };
    const brush = d3.brushX().extent([[0, 0], [defaultChartWidth, height]]).on('end', e => {
      if (e.selection) {
        const indexSelection = e.selection.map(xScale.invert);
        setRangeSelection(indexSelection);
        d3.selectAll('.time-series__brush').call(brush.move, null);
      }
    });
    d3.selectAll('.time-series__brush').call(brush);
    const resetXScale = () => setRangeSelection(undefined);
    return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, {
      key: metricName + metricIndex
    }, /*#__PURE__*/_react.default.createElement("div", {
      className: "time-series__metric-name"
    }, metricName), /*#__PURE__*/_react.default.createElement("svg", {
      preserveAspectRatio: "xMinYMin meet",
      key: "time-series--".concat(metricName),
      width: defaultChartWidth + margin.left + margin.right,
      height: height + margin.top + margin.bottom
    }, /*#__PURE__*/_react.default.createElement("defs", null, /*#__PURE__*/_react.default.createElement("clipPath", {
      id: "clip"
    }, /*#__PURE__*/_react.default.createElement("rect", {
      x: 0,
      y: 0,
      width: defaultChartWidth,
      height: height
    }))), /*#__PURE__*/_react.default.createElement("defs", null, /*#__PURE__*/_react.default.createElement("clipPath", {
      id: "brush_clip"
    }, /*#__PURE__*/_react.default.createElement("rect", {
      height: height - 1,
      width: defaultChartWidth,
      x: 0,
      y: 0.5
    }))), /*#__PURE__*/_react.default.createElement("g", {
      id: metricName,
      transform: "translate(".concat(margin.left, ",").concat(margin.top, ")")
    }, /*#__PURE__*/_react.default.createElement("g", {
      className: "time-series__runs-axis",
      ref: getXAxis,
      transform: "translate(0,".concat(height, ")")
    }), /*#__PURE__*/_react.default.createElement("g", {
      className: "time-series__metric-axis",
      ref: getYAxis
    }), /*#__PURE__*/_react.default.createElement("g", {
      className: "time-series__metric-axis-dual",
      ref: getYAxis,
      transform: "translate(".concat(defaultChartWidth, ",0)")
    }), /*#__PURE__*/_react.default.createElement("text", {
      className: "time-series__axis-label",
      x: -10 - height / 2,
      y: 10 - margin.left
    }, "value"), /*#__PURE__*/_react.default.createElement("g", {
      className: "time-series__brush",
      onDoubleClick: resetXScale
    }), /*#__PURE__*/_react.default.createElement("g", {
      className: "time-series__run-lines",
      clipPath: "url(#brush_clip)"
    }, parsedData.map((_ref10, index) => {
      let [key, _] = _ref10;
      return /*#__PURE__*/_react.default.createElement("line", {
        className: (0, _classnames.default)('time-series__run-line', {
          'time-series__run-line--hovered': hoveredElementId === runKeys[index],
          'time-series__run-line--blend': hoveredElementId || selectedRuns.length > 1
        }),
        id: runKeys[index],
        key: key + index,
        x1: xScale(key),
        y1: 0,
        x2: xScale(key),
        y2: height,
        onMouseOver: e => handleMouseOverLine(e, runKeys[index]),
        onMouseLeave: handleMouseOutLine
      });
    })), hoveredValues && /*#__PURE__*/_react.default.createElement("g", {
      className: "time-series__hovered-line-group"
    }, hoveredValues.map((value, index) => {
      if (metricIndex === index) {
        return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, {
          key: value + index
        }, /*#__PURE__*/_react.default.createElement("line", {
          className: "time-series__hovered-line",
          x1: 0,
          y1: yScales[index](value),
          x2: defaultChartWidth,
          y2: yScales[index](value)
        }), /*#__PURE__*/_react.default.createElement("g", {
          className: "time-series__ticks"
        }, /*#__PURE__*/_react.default.createElement("line", {
          className: "time-series__tick-line",
          x1: xScale(hoveredElementDate),
          y1: yScales[index](value),
          x2: xScale(hoveredElementDate) - 5,
          y2: yScales[index](value)
        }), /*#__PURE__*/_react.default.createElement("text", {
          className: "time-series__tick-text",
          x: xScale(hoveredElementDate),
          y: yScales[index](value)
        }, value === null || value === void 0 ? void 0 : value.toFixed(3))));
      } else {
        return null;
      }
    }), ";"), /*#__PURE__*/_react.default.createElement("g", {
      className: (0, _classnames.default)('time-series__metric-line', {
        'time-series__metric-line--blend': hoveredElementId || selectedRuns.length > 1
      }),
      clipPath: "url(#clip)"
    }, /*#__PURE__*/_react.default.createElement("path", {
      d: linePath(metricValues)
    })), /*#__PURE__*/_react.default.createElement("g", {
      className: "time-series__selected-group",
      clipPath: "url(#brush_clip)"
    }, getSelectedOrderedData(runData, selectedRuns).map((_ref11, index) => {
      var _value$metricIndex;
      let [key, value] = _ref11;
      return /*#__PURE__*/_react.default.createElement(_react.default.Fragment, {
        key: key + value
      }, /*#__PURE__*/_react.default.createElement("line", {
        className: "time-series__run-line--selected-".concat(index),
        x1: xScale(key),
        y1: 0,
        x2: xScale(key),
        y2: height
      }), /*#__PURE__*/_react.default.createElement("text", {
        className: "time-series__tick-text",
        x: xScale(key),
        y: yScales[metricIndex](value[metricIndex])
      }, (_value$metricIndex = value[metricIndex]) === null || _value$metricIndex === void 0 ? void 0 : _value$metricIndex.toFixed(3)), /*#__PURE__*/_react.default.createElement("path", {
        className: "time-series__marker--selected-".concat(index),
        d: "".concat(d3.symbol(selectedMarkerShape[index], 20)()),
        transform: "translate(".concat(xScale(key), ",").concat(yScales[metricIndex](value[metricIndex]), ") \n                  rotate(").concat(selectedMarkerRotate[index], ")")
      }));
    })), /*#__PURE__*/_react.default.createElement("g", {
      className: "time-series__trend-line"
    }, /*#__PURE__*/_react.default.createElement("path", {
      d: trendLinePath(selectedData)
    })))));
  }));
};
exports.TimeSeries = TimeSeries;