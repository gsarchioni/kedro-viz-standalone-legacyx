"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mapStateToProps = exports.mapDispatchToProps = exports.default = void 0;
var _react = _interopRequireWildcard(require("react"));
var _reactRedux = require("react-redux");
var _classnames = _interopRequireDefault(require("classnames"));
var _actions = require("../../actions");
var _utils = require("../../utils");
var _helpers = require("../../store/helpers");
var _config = require("../../config");
var _modal = _interopRequireDefault(require("../ui/modal"));
var _publishedView = _interopRequireDefault(require("./published-view/published-view"));
var _compatibilityErrorView = _interopRequireDefault(require("./compatibility-error-view/compatibility-error-view"));
var _mainView = _interopRequireDefault(require("./main-view/main-view"));
var _loadingView = _interopRequireDefault(require("./loading-view/loading-view"));
var _errorView = _interopRequireDefault(require("./error-view/error-view"));
var _successView = _interopRequireDefault(require("./success-view/success-view"));
var _utils2 = require("./utils");
function _getRequireWildcardCache(e) { if ("function" != typeof WeakMap) return null; var r = new WeakMap(), t = new WeakMap(); return (_getRequireWildcardCache = function (e) { return e ? t : r; })(e); }
function _interopRequireWildcard(e, r) { if (!r && e && e.__esModule) return e; if (null === e || "object" != typeof e && "function" != typeof e) return { default: e }; var t = _getRequireWildcardCache(r); if (t && t.has(e)) return t.get(e); var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) { var i = a ? Object.getOwnPropertyDescriptor(e, u) : null; i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u]; } return n.default = e, t && t.set(e, n), n; }
/* eslint-disable camelcase */

const ShareableUrlModal = _ref => {
  let {
    onToggleModal,
    visible
  } = _ref;
  const [deploymentState, setDeploymentState] = (0, _react.useState)('default');
  const [inputValues, setInputValues] = (0, _react.useState)({});
  const [isFormDirty, setIsFormDirty] = (0, _react.useState)({
    hasBucketName: false,
    hasPlatform: false,
    hasEndpoint: false
  });
  const [isLoading, setIsLoading] = (0, _react.useState)(false);
  const [responseUrl, setResponseUrl] = (0, _react.useState)(null);
  const [responseError, setResponseError] = (0, _react.useState)(null);
  const [showCopied, setShowCopied] = (0, _react.useState)(false);
  const [compatibilityData, setCompatibilityData] = (0, _react.useState)({});
  const [isCompatible, setIsCompatible] = (0, _react.useState)(true);
  const [showPublishedView, setShowPublishedView] = (0, _react.useState)(false);
  const [hostingPlatformLocalStorageVal, setHostingPlatformLocalStorageVal] = (0, _react.useState)((0, _helpers.loadLocalStorage)(_config.localStorageShareableUrl) || {});
  const [publishedPlatformKey, setPublishedPlatformKey] = (0, _react.useState)(undefined);
  const [isPreviewEnabled, setIsPreviewEnabled] = (0, _react.useState)(false);
  (0, _react.useEffect)(() => {
    async function fetchPackageCompatibility() {
      try {
        const request = await (0, _utils.fetchPackageCompatibilities)();
        const response = await request.json();
        if (request.ok) {
          const fsspecPackage = response.find(pckg => pckg.package_name === _config.PACKAGE_FSSPEC);
          setCompatibilityData(fsspecPackage);
          setIsCompatible((fsspecPackage === null || fsspecPackage === void 0 ? void 0 : fsspecPackage.is_compatible) || false);

          // User's fsspec package version isn't compatible, so set
          // the necessary state to reflect that in the UI.
          if (!fsspecPackage.is_compatible) {
            setDeploymentState(!fsspecPackage.is_compatible && 'incompatible');
          }
        }
      } catch (error) {
        console.error('package-compatibilities fetch error: ', error);
      }
    }
    fetchPackageCompatibility();
  }, []);
  const setStateForPublishedView = () => {
    if (Object.keys(hostingPlatformLocalStorageVal).length > 0) {
      setDeploymentState('published');
      setShowPublishedView(true);
      // set the publishedPlatformKey as the first one from localStorage by default
      setPublishedPlatformKey(Object.keys(hostingPlatformLocalStorageVal)[0]);
    }
  };
  const setStateForMainViewWithPublishedContent = () => {
    if (Object.keys(hostingPlatformLocalStorageVal).length > 0) {
      setShowPublishedView(false);
      setDeploymentState('default');
      const populatedContent = hostingPlatformLocalStorageVal[publishedPlatformKey];
      setInputValues(populatedContent);
      setIsFormDirty({
        hasBucketName: true,
        hasPlatform: true,
        hasEndpoint: true
      });
    }
  };
  (0, _react.useEffect)(() => {
    setStateForPublishedView();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  const onChange = (key, value) => {
    setIsFormDirty(prevState => ({
      ...prevState,
      [_config.inputKeyToStateKeyMap[key]]: !!value
    }));
    setInputValues(Object.assign({}, inputValues, {
      [key]: value
    }));
  };
  const updateFormWithLocalStorageData = platformKey => {
    // if the selected platform is stored in localStorage, populate the form with the stored data
    if (hostingPlatformLocalStorageVal[platformKey]) {
      const populatedContent = hostingPlatformLocalStorageVal[platformKey];
      setInputValues(populatedContent);
      setIsFormDirty({
        hasBucketName: true,
        hasPlatform: true,
        hasEndpoint: true
      });
    } else {
      // if not, only set the platform and reset the rest
      const emptyContent = {
        platform: platformKey,
        bucket_name: '',
        endpoint: ''
      };
      setInputValues(emptyContent);
      setIsFormDirty({
        hasBucketName: false,
        hasPlatform: true,
        hasEndpoint: false
      });
    }
  };
  const updateLocalStorageState = () => {
    const selectedHostingPlatformVal = {};
    if (_config.hostingPlatforms.hasOwnProperty(inputValues.platform)) {
      selectedHostingPlatformVal[inputValues.platform] = {
        ...inputValues
      };
    }
    (0, _helpers.saveLocalStorage)(_config.localStorageShareableUrl, selectedHostingPlatformVal);

    //  filtering out the pairs where the key is in selectedHostingPlatformVal
    const localStorageExcludingSelectedPlatform = Object.fromEntries(Object.entries(hostingPlatformLocalStorageVal).filter(_ref2 => {
      let [key] = _ref2;
      return !(key in selectedHostingPlatformVal);
    }));

    // set the new state with selectedHostingPlatformVal as the first value and localStorageExcludingSelectedPlatform
    const newState = {
      ...selectedHostingPlatformVal,
      ...localStorageExcludingSelectedPlatform
    };
    setHostingPlatformLocalStorageVal(newState);
  };
  const handleSubmit = async () => {
    setDeploymentState('loading');
    setIsLoading(true);
    setShowPublishedView(false);
    try {
      const request = await (0, _utils.deployViz)({
        ...inputValues,
        is_all_previews_enabled: isPreviewEnabled
      });
      const response = await request.json();
      if (request.ok) {
        setResponseUrl(response.url);
        setDeploymentState('success');
        updateLocalStorageState();
      } else {
        setResponseUrl(null);
        setResponseError(response.message || 'Error occurred!');
        setDeploymentState('failure');
      }
    } catch (error) {
      console.error(error);
      setResponseError(error.message || 'Error occurred!');
      setDeploymentState('failure');
    } finally {
      setIsLoading(false);
    }
  };
  const onCopyClick = url => {
    window.navigator.clipboard.writeText(url);
    setShowCopied(true);
    setTimeout(() => {
      setShowCopied(false);
    }, 1500);
  };
  const handleModalClose = () => {
    onToggleModal(false);
    if (deploymentState !== 'incompatible') {
      // reset the state to default as long as the user's fsspec package version is compatible
      //  and there are nothing stored in localStorage
      if (Object.keys(hostingPlatformLocalStorageVal).length === 0) {
        setDeploymentState('default');
      }

      // if there are items stored in localStorage, display the published view
      setStateForPublishedView();
    }
    setResponseError(null);
    setIsLoading(false);
    setResponseUrl(null);
    setInputValues({});
    setIsFormDirty({
      hasBucketName: false,
      hasPlatform: false,
      hasEndpoint: false
    });
    setIsPreviewEnabled(false);
  };
  const {
    platform
  } = inputValues || {};
  return /*#__PURE__*/_react.default.createElement(_modal.default, {
    className: (0, _classnames.default)('shareable-url-modal', {
      'shareable-url-modal__non-default-wrapper': deploymentState !== 'default',
      'shareable-url-modal__published-wrapper': deploymentState === 'published',
      'shareable-url-modal__success-wrapper': deploymentState === 'success'
    }),
    closeModal: handleModalClose,
    message: (0, _utils2.getDeploymentStateByType)('message', deploymentState, compatibilityData, _config.shareableUrlMessages),
    title: (0, _utils2.getDeploymentStateByType)('title', deploymentState, compatibilityData, _config.shareableUrlMessages),
    visible: visible.shareableUrlModal
  }, !isCompatible ? /*#__PURE__*/_react.default.createElement(_compatibilityErrorView.default, {
    onClick: handleModalClose
  }) : showPublishedView ? /*#__PURE__*/_react.default.createElement(_publishedView.default, {
    hostingPlatformLocalStorageVal: hostingPlatformLocalStorageVal,
    hostingPlatforms: _config.hostingPlatforms,
    onChange: selectedPlatform => {
      onChange('platform', selectedPlatform.value);
      setPublishedPlatformKey(selectedPlatform.value);
    },
    onCopyClick: onCopyClick,
    onRepublishClick: setStateForMainViewWithPublishedContent,
    platform: platform,
    showCopied: showCopied
  }) : /*#__PURE__*/_react.default.createElement(_react.default.Fragment, null, !isLoading && !responseUrl && !responseError && /*#__PURE__*/_react.default.createElement(_mainView.default, {
    handleModalClose: handleModalClose,
    handleSubmit: handleSubmit,
    inputValues: inputValues,
    isFormDirty: isFormDirty,
    onPlatformChange: selectedPlatform => {
      updateFormWithLocalStorageData(selectedPlatform.value);
    },
    onBuckNameChange: value => onChange('bucket_name', value),
    onEndpointChange: value => onChange('endpoint', value),
    setIsPreviewEnabled: setIsPreviewEnabled,
    isPreviewEnabled: isPreviewEnabled,
    visible: visible
  }), isLoading && /*#__PURE__*/_react.default.createElement(_loadingView.default, {
    isLoading: isLoading
  }), responseError && /*#__PURE__*/_react.default.createElement(_errorView.default, {
    onClick: () => {
      setDeploymentState('default');
      setIsLoading(false);
      setResponseUrl(null);
      setResponseError(null);
    },
    responseError: responseError
  }), responseUrl && /*#__PURE__*/_react.default.createElement(_successView.default, {
    handleResponseUrl: (0, _utils2.handleResponseUrl)(responseUrl, platform),
    onClick: onCopyClick,
    responseUrl: responseUrl,
    showCopied: showCopied
  })));
};
const mapStateToProps = state => ({
  visible: state.visible
});
exports.mapStateToProps = mapStateToProps;
const mapDispatchToProps = dispatch => ({
  onToggleModal: value => {
    dispatch((0, _actions.toggleShareableUrlModal)(value));
  }
});
exports.mapDispatchToProps = mapDispatchToProps;
var _default = exports.default = (0, _reactRedux.connect)(mapStateToProps, mapDispatchToProps)(ShareableUrlModal);