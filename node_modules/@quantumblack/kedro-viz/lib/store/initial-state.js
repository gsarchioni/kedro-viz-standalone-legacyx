"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.preparePipelineState = exports.prepareNonPipelineState = exports.mergeLocalStorage = exports.default = exports.createInitialState = void 0;
var _deepmerge = _interopRequireDefault(require("deepmerge"));
var _helpers = require("./helpers");
var _normalizeData = _interopRequireDefault(require("./normalize-data"));
var _flags = require("../utils/flags");
var _utils = require("../utils");
var _config = require("../config");
/**
 * Create new default state instance for properties that aren't overridden
 * when the pipeline is reset with new data via the App component's data prop
 * @return {Object} state
 */
const createInitialState = () => ({
  chartSize: {},
  flags: _flags.Flags.defaults(),
  textLabels: true,
  theme: 'dark',
  expandAllPipelines: false,
  isPrettyName: _config.settings.isPrettyName.default,
  showFeatureHints: _config.settings.showFeatureHints.default,
  userPreferences: {
    showDatasetPreviews: _config.settings.showDatasetPreviews.default
  },
  ignoreLargeWarning: false,
  loading: {
    graph: false,
    pipeline: false,
    node: false
  },
  visible: {
    code: false,
    exportModal: false,
    graph: true,
    metadataModal: false,
    miniMap: true,
    modularPipelineFocusMode: null,
    settingsModal: false,
    shareableUrlModal: false,
    sidebar: window.innerWidth > _config.sidebarWidth.breakpoint
  },
  display: {
    globalNavigation: true,
    sidebar: true,
    miniMap: true,
    expandPipelinesBtn: true,
    exportBtn: true,
    labelBtn: true,
    layerBtn: true,
    zoomToolbar: true,
    metadataPanel: true
  },
  zoom: {},
  runsMetadata: {}
});
exports.createInitialState = createInitialState;
const parseUrlParameters = () => {
  const search = new URLSearchParams(window.location.search);
  return {
    pipelineIdFromURL: search.get(_config.params.pipeline),
    nodeIdFromUrl: search.get(_config.params.selected),
    nodeNameFromUrl: search.get(_config.params.selectedName),
    nodeTypeInUrl: search.get(_config.params.types) ? search.get(_config.params.types).split(',') : [],
    nodeTagInUrl: search.get(_config.params.tags) ? search.get(_config.params.tags).split(',') : [],
    expandAllPipelinesInUrl: search.get(_config.params.expandAll)
  };
};

/**
 * Applies URL parameters to the application pipeline state.
 * This function modifies the state based on the URL parameters such as
 * pipeline ID, node ID, node name, node type presence, and tag presence.
 *
 * @param {Object} state The current application pipeline state.
 * @param {Object} urlParams An object containing parsed URL parameters.
 * @returns {Object} The new state with modifications applied based on the URL parameters.
 */
const applyUrlParametersToPipelineState = (state, urlParams) => {
  const {
    pipelineIdFromURL,
    nodeIdFromUrl,
    nodeNameFromUrl,
    nodeTypeInUrl,
    nodeTagInUrl
  } = urlParams;
  let newState = {
    ...state
  };
  const nodeTypes = ['parameters', 'task', 'data'];

  // Use main pipeline if pipeline from URL isn't recognised
  if (pipelineIdFromURL) {
    newState.pipeline.active = newState.pipeline.ids.includes(pipelineIdFromURL) ? pipelineIdFromURL : newState.pipeline.main;
  }

  // Ensure data tags are on to allow redirection back to the selected node
  if (nodeNameFromUrl) {
    newState.nodeType.disabled.data = false;
  }
  if (nodeTypeInUrl.length) {
    Object.keys(newState.nodeType.disabled).forEach(key => {
      newState.nodeType.disabled[key] = true;
    });
    nodeTypeInUrl.forEach(key => {
      newState.nodeType.disabled[(0, _utils.mapNodeType)(key)] = false;
    });
  }

  // Enable node types based on presence in URL and current node type settings
  if (nodeIdFromUrl && nodeTypes.includes(state.node.type[nodeIdFromUrl])) {
    newState.nodeType.disabled[newState.node.type[nodeIdFromUrl]] = false;
  }
  if (nodeTagInUrl.length) {
    // Set all tags to false initially
    Object.keys(newState.tag.enabled).forEach(key => {
      newState.tag.enabled[key] = false;
    });
    nodeTagInUrl.forEach(tag => {
      newState.tag.enabled[tag] = true;
    });
  }
  return newState;
};

/**
 * Applies URL parameters to the application non-pipeline state.
 * This function modifies the state based on the URL parameters such as
 * expandAllPipelines presence.
 *
 * @param {Object} state The current application non-pipeline state.
 * @param {Object} urlParams An object containing parsed URL parameters.
 * @returns {Object} The new state with modifications applied based on the URL parameters.
 */
const applyUrlParametersToNonPipelineState = (state, urlParams) => {
  const {
    expandAllPipelinesInUrl
  } = urlParams;
  let newState = {
    ...state
  };
  if (expandAllPipelinesInUrl && (0, _utils.isValidBoolean)(expandAllPipelinesInUrl)) {
    newState.expandAllPipelines = JSON.parse(expandAllPipelinesInUrl);
  }
  return newState;
};

/**
 * Load values from localStorage and combine with existing state,
 * but filter out any unused values from localStorage
 * @param {Object} state Initial/extant state
 * @return {Object} Combined state from localStorage
 */
const mergeLocalStorage = state => {
  const localStorageState = (0, _helpers.loadLocalStorage)(_config.localStorageName);
  const localStorageRunsMetadataState = (0, _helpers.loadLocalStorage)(_config.localStorageRunsMetadata);
  Object.keys(localStorageState).forEach(key => {
    if (!(key in state)) {
      delete localStorageState[key];
    }
  });
  const allLocalStorageState = {
    ...localStorageState,
    ...{
      runsMetadata: localStorageRunsMetadataState
    }
  };
  return (0, _deepmerge.default)(state, allLocalStorageState);
};

/**
 * Prepare the pipeline data part of the state by normalizing the raw data,
 * and applying saved state from localStorage.
 * This part is separated so that it can be reset without overriding user settings,
 * because it can be run both on initial state load and again later on.
 * The applyFixes part should only ever be run once, on first load.
 * Exactly when it runs depends on whether the data is loaded asynchronously or not.
 * @param {Object} data Data prop passed to App component
 * @param {Boolean} applyFixes Whether to override initialState
 * @param {Boolean} expandAllPipelines Whether to expand all the modular pipelines
 * @param {Object} urlParams An object containing parsed URL parameters.
 * @returns {Object} The new pipeline state with modifications applied.
 */
exports.mergeLocalStorage = mergeLocalStorage;
const preparePipelineState = (data, applyFixes, expandAllPipelines, urlParams) => {
  let state = mergeLocalStorage((0, _normalizeData.default)(data, expandAllPipelines));
  if (applyFixes) {
    // Use main pipeline if active pipeline from localStorage isn't recognised
    if (!state.pipeline.ids.includes(state.pipeline.active)) {
      state.pipeline.active = state.pipeline.main;
    }
  }
  if (urlParams) {
    state = applyUrlParametersToPipelineState(state, urlParams);
  }
  return state;
};

/**
 * Prepare the non-pipeline data part of the state. This part is separated so that it
 * will persist if the pipeline data is reset.
 * Merge local storage and add custom state overrides from props etc
 * @param {object} props Props passed to App component
 * @param {Object} urlParams An object containing parsed URL parameters.
 * @returns {Object} The new non-pipeline state with modifications applied.
 */
exports.preparePipelineState = preparePipelineState;
const prepareNonPipelineState = urlParams => {
  let state = mergeLocalStorage(createInitialState());
  if (urlParams) {
    state = applyUrlParametersToNonPipelineState(state, urlParams);
  }
  return {
    ...state,
    flags: {
      ...state.flags,
      ...(0, _flags.getFlagsFromUrl)()
    }
  };
};

/**
 * Configure the redux store's initial state, by merging default values
 * with normalised pipeline data and localStorage.
 * If parameters flag is set to true, then disable parameters on initial load
 * @param {Object} props App component props
 * @return {Object} Initial state
 */
exports.prepareNonPipelineState = prepareNonPipelineState;
const getInitialState = function () {
  let props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  const urlParams = parseUrlParameters();
  const nonPipelineState = prepareNonPipelineState(urlParams);
  let expandAllPipelines = nonPipelineState.expandAllPipelines;
  if (props.options) {
    expandAllPipelines = props.options.expandAllPipelines || nonPipelineState.expandAllPipelines;
  }
  const pipelineState = preparePipelineState(props.data, props.data !== 'json', expandAllPipelines, urlParams);
  const initialState = {
    ...nonPipelineState,
    ...pipelineState
  };
  return props.options ? (0, _deepmerge.default)(initialState, props.options) : initialState;
};
var _default = exports.default = getInitialState;