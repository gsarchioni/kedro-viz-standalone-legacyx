"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVisibleNodeIDs = exports.getVisibleLayerIDs = exports.getNodeDisabledTag = exports.getNodeDisabled = exports.getEdgeDisabled = void 0;
var _reselect = require("reselect");
var _utils = require("../utils");
var _pipeline = require("./pipeline");
var _modularPipelines = require("./modular-pipelines");
var _tags = require("./tags");
const getNodeIDs = state => state.node.ids;
const getNodeDisabledNode = state => state.node.disabled;
const getDisabledModularPipeline = state => state.modularPipeline.disabled;
const getNodeTags = state => state.node.tags;
const getNodeType = state => state.node.type;
const getTagEnabled = state => state.tag.enabled;
const getNodeTypeDisabled = state => state.nodeType.disabled;
const getEdgeIDs = state => state.edge.ids;
const getEdgeSources = state => state.edge.sources;
const getEdgeTargets = state => state.edge.targets;
const getLayerIDs = state => state.layer.ids;
const getLayersVisible = state => state.layer.visible;
const getNodeLayer = state => state.node.layer;
const getNodeModularPipelines = state => state.node.modularPipelines;
const getVisibleSidebarNodes = state => state.modularPipeline.visible;

/**
 * Return all inputs and outputs of currently visible modular pipelines
 * so that even if they are not expanded, their inputs and outputs are still rendered.
 */
const getVisibleModularPipelineInputsOutputs = (0, _reselect.createSelector)([getVisibleSidebarNodes, _modularPipelines.getModularPipelinesTree], (visibleSidebarNodes, modularPipelineData) => {
  const result = new Set();
  for (const nodeID in visibleSidebarNodes) {
    if (visibleSidebarNodes[nodeID] && nodeID in modularPipelineData) {
      [...modularPipelineData[nodeID].inputs, ...modularPipelineData[nodeID].outputs].forEach(nodeID => result.add(nodeID));
    }
  }
  return result;
});

/**
 * Calculate whether nodes should be disabled based on their tags
 */
const getNodeDisabledTag = exports.getNodeDisabledTag = (0, _reselect.createSelector)([getNodeIDs, getTagEnabled, _tags.getTagCount, getNodeTags], (nodeIDs, tagEnabled, tagCount, nodeTags) => (0, _utils.arrayToObject)(nodeIDs, nodeID => {
  if (tagCount.enabled === 0) {
    return false;
  }
  if (nodeTags[nodeID].length) {
    // Hide task nodes that don't have at least one tag filter enabled
    return !nodeTags[nodeID].some(tag => tagEnabled[tag]);
  }
  return true;
}));

/**
 * Set disabled status if the node is specifically hidden, and/or via a tag/view/type/modularPipeline
 */
const getNodeDisabled = exports.getNodeDisabled = (0, _reselect.createSelector)([getNodeIDs, getNodeDisabledNode, getNodeDisabledTag, _pipeline.getNodeDisabledPipeline, getNodeType, getNodeTypeDisabled, getNodeModularPipelines, _modularPipelines.getModularPipelinesTree, _modularPipelines.getFocusedModularPipeline, getVisibleSidebarNodes, getVisibleModularPipelineInputsOutputs, getDisabledModularPipeline], (nodeIDs, nodeDisabledNode, nodeDisabledTag, nodeDisabledPipeline, nodeType, typeDisabled, nodeModularPipelines, modularPipelinesTree, focusedModularPipeline, visibleSidebarNodes, visibleModularPipelineInputsOutputs, disabledModularPipeline) => (0, _utils.arrayToObject)(nodeIDs, id => {
  let isDisabledViaModularPipeline = disabledModularPipeline[nodeModularPipelines[id]];
  const isDisabledViaSidebar = !visibleSidebarNodes[id] && !visibleModularPipelineInputsOutputs.has(id);
  let isDisabledViaFocusedModularPipeline = false;
  if (focusedModularPipeline) {
    const inputOutputNodeIDs = [...modularPipelinesTree[focusedModularPipeline.id].inputs, ...modularPipelinesTree[focusedModularPipeline.id].outputs];
    if (nodeType[id] === 'modularPipeline') {
      isDisabledViaFocusedModularPipeline = id !== focusedModularPipeline.id && !id.startsWith("".concat(focusedModularPipeline.id, "."));
    } else {
      isDisabledViaFocusedModularPipeline = !nodeModularPipelines[id].includes(focusedModularPipeline.id) && !inputOutputNodeIDs.includes(id);
    }
  }
  return [nodeDisabledNode[id], nodeDisabledTag[id], nodeDisabledPipeline[id], disabledModularPipeline[id], typeDisabled[nodeType[id]], isDisabledViaSidebar, isDisabledViaModularPipeline, isDisabledViaFocusedModularPipeline].some(Boolean);
}));

/**
 * Get a list of just the IDs for the remaining visible nodes
 */
const getVisibleNodeIDs = exports.getVisibleNodeIDs = (0, _reselect.createSelector)([_pipeline.getPipelineNodeIDs, getNodeDisabled], (nodeIDs, nodeDisabled) => {
  return nodeIDs.filter(id => !nodeDisabled[id]);
});

/**
 * Get a list of just the IDs for the remaining visible layers
 */
const getVisibleLayerIDs = exports.getVisibleLayerIDs = (0, _reselect.createSelector)([getVisibleNodeIDs, getNodeLayer, getLayerIDs, getLayersVisible], (nodeIDs, nodeLayer, layerIDs, layersVisible) => {
  if (!layersVisible) {
    return [];
  }
  const visibleLayerIDs = {};
  for (const nodeID of nodeIDs) {
    visibleLayerIDs[nodeLayer[nodeID]] = true;
  }
  return layerIDs.filter(layerID => visibleLayerIDs[layerID]);
});

/**
 * Determine whether an edge should be disabled based on their source/target nodes
 */
const getEdgeDisabled = exports.getEdgeDisabled = (0, _reselect.createSelector)([getEdgeIDs, getNodeDisabled, getEdgeSources, getEdgeTargets], (edgeIDs, nodeDisabled, edgeSources, edgeTargets) => (0, _utils.arrayToObject)(edgeIDs, edgeID => {
  const source = edgeSources[edgeID];
  const target = edgeTargets[edgeID];
  return Boolean(nodeDisabled[source] || nodeDisabled[target]);
}));