"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.searchTree = exports.searchString = exports.getModularPipelinesTree = exports.getModularPipelinesSearchResult = exports.getModularPipelineIDs = exports.getFocusedModularPipeline = void 0;
var _searchUtils = require("../utils/search-utils");
const getModularPipelineIDs = state => state.modularPipeline.ids;
exports.getModularPipelineIDs = getModularPipelineIDs;
const getFocusedModularPipeline = state => state.visible.modularPipelineFocusMode;
exports.getFocusedModularPipeline = getFocusedModularPipeline;
const getModularPipelinesTree = state => state.modularPipeline.tree;

/**
 * Search a given string in a string target.
 * Return whether there is a match.
 * @param {String} searchValue the string to search for.
 * @param {String} target the target to search in.
 * @return {Boolean} whether there is a match.
 */
exports.getModularPipelinesTree = getModularPipelinesTree;
const searchString = (searchValue, target) => {
  if (!searchValue || !target) {
    return false;
  }
  return new RegExp((0, _searchUtils.escapeRegExp)(target), 'gi').test(searchValue);
};

/**
 * Return whether a tree node in a modular pipeline tree is a leaf.
 */
exports.searchString = searchString;
const isTreeLeaf = treeNode => treeNode.type !== 'modularPipeline';

/**
 * Search a given string in a (modular pipelines) tree.
 */
const searchTree = function (searchValue, tree) {
  let currentNodeID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '__root__';
  let result = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
  const treeNode = tree[currentNodeID];
  if (!treeNode) {
    return false;
  }
  const foundChildren = [];
  for (const childNode of treeNode.children) {
    if (isTreeLeaf(childNode)) {
      // if the child node is a leaf, simply search the leaf's name
      // and add to the search result if there is a match.
      const found = searchString(childNode.data.name, searchValue);
      const foundOpposite = searchString(childNode.data.oppositeForPrettyName, searchValue);

      //First looking for match based on prettyName flag and render accordingly
      // and if not found than rendering based on opposite of prettyName flag
      if (found) {
        foundChildren.push({
          ...childNode,
          data: {
            ...childNode.data,
            highlightedLabel: (0, _searchUtils.getHighlightedText)(childNode.data.name, searchValue)
          }
        });
      } else {
        if (foundOpposite) {
          foundChildren.push({
            ...childNode,
            data: {
              ...childNode.data,
              highlightedLabel: (0, _searchUtils.getHighlightedText)(childNode.data.oppositeForPrettyName, searchValue)
            }
          });
        }
      }
    } else {
      // if the child node is a tree, recursively search it
      // and add the child node to the list of found children
      // if there is a matching value in its tree.
      const found = searchTree(searchValue, tree, childNode.id, result);
      if (found) {
        var _result$childNode$id;
        foundChildren.push({
          ...childNode,
          highlightedLabel: (0, _searchUtils.getHighlightedText)(((_result$childNode$id = result[childNode.id]) === null || _result$childNode$id === void 0 ? void 0 : _result$childNode$id.name) || '', searchValue)
        });
      }
    }
  }
  if (foundChildren.length > 0 || searchString(treeNode.name, searchValue)) {
    result[currentNodeID] = {
      ...treeNode,
      highlightedLabel: (0, _searchUtils.getHighlightedText)(treeNode.name, searchValue),
      children: foundChildren
    };
    return true;
  }
  return false;
};

/**
 * Search a given value in a modularPipelinesTree
 * and return a tree structure containing the searchResult.
 * @param {Object} modularPipelinesTree the modular pipelines tree to search in.
 * @param {String} searchValue the value to search for in the given modular pipelines tree.
 * @return {Object} a tree structure containing the searchResult.
 */
exports.searchTree = searchTree;
const getModularPipelinesSearchResult = (modularPipelinesTree, searchValue) => {
  if (!modularPipelinesTree) {
    return {};
  }
  const searchResult = {};
  searchTree(searchValue, modularPipelinesTree, '__root__', searchResult);
  return searchResult;
};
exports.getModularPipelinesSearchResult = getModularPipelinesSearchResult;