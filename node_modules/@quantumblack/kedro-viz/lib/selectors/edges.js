"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVisibleEdges = exports.getTransitiveEdges = exports.getInputOutputDataEdges = exports.addNewEdge = void 0;
var _reselect = require("reselect");
var _disabled = require("./disabled");
var _modularPipelines = require("./modular-pipelines");
const getNodeIDs = state => state.node.ids;
const getEdgeIDs = state => state.edge.ids;
const getEdgeSources = state => state.edge.sources;
const getEdgeTargets = state => state.edge.targets;
const getNodeModularPipelines = state => state.node.modularPipelines;
const getVisibleSidebarNodes = state => state.modularPipeline.visible;

/**
 * Create a new transitive edge from the first and last edge in the path
 * @param {String} target Node ID for the new edge
 * @param {String} source Node ID for the new edge
 * @param {Object} transitiveEdges Store of existing edges
 */
const addNewEdge = (source, target, _ref) => {
  let {
    edgeIDs,
    sources,
    targets
  } = _ref;
  const id = [source, target].join('|');
  if (!edgeIDs.includes(id)) {
    edgeIDs.push(id);
    sources[id] = source;
    targets[id] = target;
  }
};

/**
 * Create new edges to connect nodes which have a disabled node (or nodes)
 * in between them
 */
exports.addNewEdge = addNewEdge;
const getTransitiveEdges = exports.getTransitiveEdges = (0, _reselect.createSelector)([getNodeIDs, getEdgeIDs, _disabled.getNodeDisabled, getEdgeSources, getEdgeTargets, _modularPipelines.getFocusedModularPipeline, getNodeModularPipelines, getVisibleSidebarNodes], (nodeIDs, edgeIDs, nodeDisabled, edgeSources, edgeTargets, focusedModularPipeline, nodeModularPipelines, visibleModularPipelines) => {
  const transitiveEdges = {
    edgeIDs: [],
    sources: {},
    targets: {}
  };

  /**
   * Recursively walk through the graph, stepping over disabled nodes,
   * generating a list of nodes visited so far, and create transitive edges
   * for each path that visits disabled nodes between enabled nodes.
   * @param {Array} path The route that has been explored so far
   */
  const walkGraphEdges = path => {
    edgeIDs.forEach(edgeID => {
      const source = path[path.length - 1];
      // Filter to only edges where the source node is the previous target
      if (edgeSources[edgeID] !== source) {
        return;
      }
      const target = edgeTargets[edgeID];
      if (!visibleModularPipelines[target]) {
        return;
      }

      // Further filter out connections between indicative input / output nodes under focus mode
      const isNotInputEdge = focusedModularPipeline !== null && !nodeModularPipelines[source].includes(focusedModularPipeline.id) && !nodeModularPipelines[target].includes(focusedModularPipeline.id);
      if (nodeDisabled[target]) {
        // If target node is disabled then keep walking the graph
        walkGraphEdges(path.concat(target));
      } else if (path.length > 1 && !isNotInputEdge) {
        // Else only create a new edge if there would be 3 or more nodes in the path
        addNewEdge(path[0], target, transitiveEdges);
      }
    });
  };

  // Only run walk if some nodes are disabled
  if (nodeIDs.some(nodeID => nodeDisabled[nodeID])) {
    // Examine the children of every enabled node. The walk only needs
    // to be run in a single direction (i.e. top down), because links
    // that end in a terminus can never be transitive.
    nodeIDs.forEach(nodeID => {
      if (!nodeDisabled[nodeID]) {
        walkGraphEdges([nodeID]);
      }
    });
  }
  return transitiveEdges;
});

/**
 * Get only the visible edges (plus transitive edges),
 * and return them formatted as an array of objects
 */
const getVisibleEdges = exports.getVisibleEdges = (0, _reselect.createSelector)([getEdgeIDs, _disabled.getEdgeDisabled, getEdgeSources, getEdgeTargets, getTransitiveEdges], (edgeIDs, edgeDisabled, edgeSources, edgeTargets, transitiveEdges) => edgeIDs.filter(id => !edgeDisabled[id]).concat(transitiveEdges.edgeIDs).map(id => ({
  id,
  source: edgeSources[id] || transitiveEdges.sources[id],
  target: edgeTargets[id] || transitiveEdges.targets[id]
})));

/**
 * Obtain all the edges that belongs to input and output data
 * nodes when under focus mode.
 */
const getInputOutputDataEdges = exports.getInputOutputDataEdges = (0, _reselect.createSelector)([getVisibleEdges, getNodeModularPipelines, _modularPipelines.getFocusedModularPipeline], (visibleEdges, nodeModularPipelines, focusedModularPipeline) => {
  const edgesList = {};
  if (focusedModularPipeline !== null) {
    visibleEdges.forEach(edge => {
      var _nodeModularPipelines, _nodeModularPipelines2;
      if (!((_nodeModularPipelines = nodeModularPipelines[edge.source]) !== null && _nodeModularPipelines !== void 0 && _nodeModularPipelines.includes(focusedModularPipeline.id)) || !((_nodeModularPipelines2 = nodeModularPipelines[edge.target]) !== null && _nodeModularPipelines2 !== void 0 && _nodeModularPipelines2.includes(focusedModularPipeline.id))) {
        edgesList[edge.id] = edge;
      }
    });
  }
  return edgesList;
});