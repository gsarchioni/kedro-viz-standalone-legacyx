"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTriggerLargeGraphWarning = exports.getSidebarWidth = exports.getGraphInput = exports.getChartZoom = exports.getChartSize = void 0;
var _reselect = require("reselect");
var _nodes = require("./nodes");
var _edges = require("./edges");
var _disabled = require("./disabled");
var _metadata = require("./metadata");
var _config = require("../config");
const getSizeWarningFlag = state => state.flags.sizewarning;
const getVisibleSidebar = state => state.visible.sidebar;
const getDisplayGlobalNavigation = state => state.display.globalNavigation;
const getDisplaySidebar = state => state.display.sidebar;
const getVisibleCode = state => state.visible.code;
const getIgnoreLargeWarning = state => state.ignoreLargeWarning;
const getGraphHasNodes = state => {
  var _state$graph;
  return Boolean((_state$graph = state.graph) === null || _state$graph === void 0 || (_state$graph = _state$graph.nodes) === null || _state$graph === void 0 ? void 0 : _state$graph.length);
};
const getChartSizeState = state => state.chartSize;

/**
 * Show the large graph warning only if there are sufficient nodes + edges,
 * and it hasn't been toggled off (by clicking the Render Anyway button), and
 * the graph layout hasn't already previously been calculated (due to a user
 * filtering the graph to a smaller subset), and the flag isn't set to false.
 */
const getTriggerLargeGraphWarning = exports.getTriggerLargeGraphWarning = (0, _reselect.createSelector)([_nodes.getVisibleNodes, _edges.getVisibleEdges, getIgnoreLargeWarning, getGraphHasNodes, getSizeWarningFlag], (nodes, edges, ignoreLargeWarning, graphHasNodes, sizeWarningFlag) => nodes.length + 1.5 * edges.length > _config.largeGraphThreshold && !ignoreLargeWarning && !graphHasNodes && sizeWarningFlag);

/**
 * Select a subset of state that is watched by graph layout calculators
 * and used to prepare state.graph via async web worker actions
 */
const getGraphInput = exports.getGraphInput = (0, _reselect.createSelector)([_nodes.getVisibleNodes, _edges.getVisibleEdges, _disabled.getVisibleLayerIDs, getTriggerLargeGraphWarning], (nodes, edges, layers, triggerLargeGraphWarning) => {
  if (triggerLargeGraphWarning) {
    return null;
  }
  return {
    nodes,
    edges,
    layers
  };
});

/**
 * Calculate the displayed width of a sidebar
 */
const getSidebarWidth = (visible, _ref) => {
  let {
    open,
    closed
  } = _ref;
  return visible ? open : closed;
};

/**
 * Convert the DOMRect into an Object, mutate some of the properties,
 * and add some useful new ones
 */
exports.getSidebarWidth = getSidebarWidth;
const getChartSize = exports.getChartSize = (0, _reselect.createSelector)([getVisibleSidebar, _metadata.getVisibleMetaSidebar, getVisibleCode, getChartSizeState, getDisplaySidebar, getDisplayGlobalNavigation], (visibleSidebar, visibleMetaSidebar, visibleCodeSidebar, chartSize, displaySidebar, displayGlobalNavigation) => {
  const {
    left,
    top,
    width,
    height
  } = chartSize;
  if (!width || !height) {
    return {};
  }

  // Determine if the sidebar is visible and open
  const isSidebarVisible = displaySidebar && visibleSidebar;

  // Get the actual sidebar width
  const sidebarWidthActual = displaySidebar || displayGlobalNavigation ? getSidebarWidth(isSidebarVisible, _config.sidebarWidth) : 0;
  const metaSidebarWidthActual = getSidebarWidth(visibleMetaSidebar, _config.metaSidebarWidth);
  const codeSidebarWidthActual = getSidebarWidth(visibleCodeSidebar, _config.codeSidebarWidth);

  // Find the resulting space for the chart
  let chartWidth = width - sidebarWidthActual - metaSidebarWidthActual - codeSidebarWidthActual;
  return {
    left,
    top,
    outerWidth: width,
    outerHeight: height,
    height,
    width: chartWidth,
    minWidthScale: _config.chartMinWidthScale,
    sidebarWidth: sidebarWidthActual,
    metaSidebarWidth: metaSidebarWidthActual,
    codeSidebarWidth: codeSidebarWidthActual
  };
});

/**
 * Gets the current chart zoom
 */
const getChartZoom = exports.getChartZoom = (0, _reselect.createSelector)([state => state.zoom], zoom => ({
  ...zoom
}));