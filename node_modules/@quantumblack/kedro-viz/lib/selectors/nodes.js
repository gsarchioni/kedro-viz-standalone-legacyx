"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getVisibleNodes = exports.getTagsForNodesAndModularPipelines = exports.getPadding = exports.getOppositeForPrettyName = exports.getNodesWithInputParams = exports.getNodeTextWidth = exports.getNodeSize = exports.getNodeSelected = exports.getNodeName = exports.getNodeModularPipelines = exports.getNodeLabel = exports.getNodeFullName = exports.getNodeDataObject = exports.getNodeData = exports.getNodeActive = exports.getModularPipelinesTree = exports.getInputOutputNodesForFocusedModularPipeline = exports.getGroupedNodes = exports.getGraphNodes = void 0;
var _reselect = require("reselect");
var _d3Selection = require("d3-selection");
var _utils = require("../utils");
var _pipeline = require("./pipeline");
var _disabled = require("./disabled");
var _shortType = _interopRequireDefault(require("../utils/short-type"));
var _ranks = require("./ranks");
const getNodeName = state => state.node.name;
exports.getNodeName = getNodeName;
const getNodeFullName = state => state.node.fullName;
exports.getNodeFullName = getNodeFullName;
const getNodeDisabledNode = state => state.node.disabled;
const getModularPipelineDisabled = state => state.modularPipeline.disabled;
const getNodeTags = state => state.node.tags;
const getNodeModularPipelines = state => state.node.modularPipelines;
exports.getNodeModularPipelines = getNodeModularPipelines;
const getNodeType = state => state.node.type;
const getNodeDatasetType = state => state.node.datasetType;
const getNodeLayer = state => state.node.layer;
const getHoveredNode = state => state.node.hovered;
const getIsPrettyName = state => state.isPrettyName;
const getTagActive = state => state.tag.active;
const getModularPipelineActive = state => state.modularPipeline.active;
const getTextLabels = state => state.textLabels;
const getNodeTypeDisabled = state => state.nodeType.disabled;
const getClickedNode = state => state.node.clicked;
const getEdgeIDs = state => state.edge.ids;
const getEdgeSources = state => state.edge.sources;
const getEdgeTargets = state => state.edge.targets;

/**
 * Gets a map of nodeIds to graph nodes
 */
const getGraphNodes = exports.getGraphNodes = (0, _reselect.createSelector)([state => state.graph.nodes], function () {
  let nodes = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return nodes.reduce((result, node) => {
    result[node.id] = node;
    return result;
  }, {});
});

/**
 * Retrieves tags associated with both nodes and their corresponding modular pipelines.
 */
const getTagsForNodesAndModularPipelines = exports.getTagsForNodesAndModularPipelines = (0, _reselect.createSelector)([getNodeTags, getNodeModularPipelines], (nodeTags, nodeModularPipelines) => {
  const updatedNodeTags = {
    ...nodeTags
  };
  Object.entries(nodeTags).filter(_ref => {
    let [, tags] = _ref;
    return tags.length > 0;
  }).forEach(_ref2 => {
    let [nodeID, tags] = _ref2;
    const modularPipelineIDs = nodeModularPipelines[nodeID] || [];
    modularPipelineIDs.forEach(modularPipelineID => {
      if (!updatedNodeTags[modularPipelineID]) {
        updatedNodeTags[modularPipelineID] = [];
      }
      tags.forEach(tag => {
        if (!updatedNodeTags[modularPipelineID].includes(tag)) {
          updatedNodeTags[modularPipelineID].push(tag);
        }
      });
    });
  });
  return updatedNodeTags;
});

/**
 * Set active status if the node is specifically highlighted, and/or via an associated tag or modular pipeline
 */
const getNodeActive = exports.getNodeActive = (0, _reselect.createSelector)([_pipeline.getPipelineNodeIDs, getHoveredNode, getTagsForNodesAndModularPipelines, getTagActive, getNodeModularPipelines, getModularPipelineActive, state => state.modularPipeline.tree], (nodeIDs, hoveredNode, nodeTags, tagActive, nodeModularPipelines, modularPipelineActive, modularPipelinesTree) => {
  const activeModularPipelines = Object.keys(modularPipelineActive).filter(modularPipelineID => modularPipelineActive[modularPipelineID]);
  const nodesActiveViaModularPipeline = activeModularPipelines.flatMap(id => modularPipelinesTree[id].children.map(child => child.id));
  return (0, _utils.arrayToObject)(nodeIDs, nodeID => {
    if (nodeID === hoveredNode) {
      return true;
    }
    const activeViaTag = nodeTags[nodeID].some(tag => tagActive[tag]);
    const activeModularPipeline = activeModularPipelines.includes(nodeID);
    const activeViaModularPipeline = nodesActiveViaModularPipeline.includes(nodeID) || nodeModularPipelines[nodeID] && nodeModularPipelines[nodeID].some(modularPipeline => modularPipelineActive[modularPipeline]);
    return Boolean(activeViaTag) || Boolean(activeViaModularPipeline) || Boolean(activeModularPipeline);
  });
});

/**
 * Set selected status if the node is clicked
 */
const getNodeSelected = exports.getNodeSelected = (0, _reselect.createSelector)([_pipeline.getPipelineNodeIDs, getClickedNode, _disabled.getNodeDisabled], (nodeIDs, clickedNode, nodeDisabled) => (0, _utils.arrayToObject)(nodeIDs, nodeID => nodeID === clickedNode && !nodeDisabled[nodeID]));

/**
 * Returns node label based on if pretty name is turned on/off
 */
const getNodeLabel = exports.getNodeLabel = (0, _reselect.createSelector)([getIsPrettyName, getNodeName, getNodeFullName], (isPrettyName, nodeName, nodeFullName) => isPrettyName ? nodeName : nodeFullName);

/**
 * Returns opposite node label based on if pretty name is turned on/off
 */
const getOppositeForPrettyName = exports.getOppositeForPrettyName = (0, _reselect.createSelector)([getIsPrettyName, getNodeName, getNodeFullName], (isPrettyName, nodeName, nodeFullName) => isPrettyName ? nodeFullName : nodeName);

/**
 * Returns formatted nodes as an array, with all relevant properties
 */
const getNodeData = exports.getNodeData = (0, _reselect.createSelector)([_pipeline.getPipelineNodeIDs, getNodeLabel, getNodeType, getNodeDatasetType, _disabled.getNodeDisabled, getModularPipelineDisabled, getNodeDisabledNode, _disabled.getNodeDisabledTag, getNodeTypeDisabled, getNodeModularPipelines], (nodeIDs, nodeLabel, nodeType, nodeDatasetType, nodeDisabled, modularPipelineDisabled, nodeDisabledNode, nodeDisabledTag, typeDisabled, nodeModularPipelines) => nodeIDs.sort((a, b) => {
  if (nodeLabel[a] < nodeLabel[b]) {
    return -1;
  }
  if (nodeLabel[a] > nodeLabel[b]) {
    return 1;
  }
  return 0;
}).map(id => ({
  id,
  name: nodeLabel[id],
  type: nodeType[id],
  icon: (0, _shortType.default)(nodeDatasetType[id], nodeType[id]),
  modularPipelines: nodeModularPipelines[id],
  disabled: nodeDisabled[id],
  disabledModularPipeline: Boolean(modularPipelineDisabled[id]),
  disabledNode: Boolean(nodeDisabledNode[id]),
  disabledTag: nodeDisabledTag[id],
  disabledType: Boolean(typeDisabled[nodeType[id]])
})));

/**
 * Returns formatted nodes as an object, with all relevant properties.
 * This is similar to `getNodeData`, but instead of returning an Array,
 * it returns all nodes as an Object.
 */
const getNodeDataObject = exports.getNodeDataObject = (0, _reselect.createSelector)([_pipeline.getPipelineNodeIDs, getNodeLabel, getNodeType, getNodeDatasetType, _disabled.getNodeDisabled, getModularPipelineDisabled, getNodeDisabledNode, _disabled.getNodeDisabledTag, getNodeTypeDisabled, getNodeModularPipelines, getOppositeForPrettyName], (nodeIDs, nodeLabel, nodeType, nodeDatasetType, nodeDisabled, modularPipelineDisabled, nodeDisabledNode, nodeDisabledTag, typeDisabled, nodeModularPipelines, oppositeForPrettyName) => nodeIDs.reduce((obj, id) => {
  obj[id] = {
    id,
    name: nodeLabel[id],
    oppositeForPrettyName: oppositeForPrettyName[id],
    type: nodeType[id],
    icon: (0, _shortType.default)(nodeDatasetType[id], nodeType[id]),
    modularPipelines: nodeModularPipelines[id],
    disabled: nodeDisabled[id],
    disabledModularPipeline: Boolean(modularPipelineDisabled[id]),
    disabledNode: Boolean(nodeDisabledNode[id]),
    disabledTag: Boolean(nodeDisabledTag[id]),
    disabledType: Boolean(typeDisabled[nodeType[id]])
  };
  return obj;
}, {}));

/**
 * Return the modular pipelines tree with full data for each tree node for display.
 */
const getModularPipelinesTree = exports.getModularPipelinesTree = (0, _reselect.createSelector)([state => state.modularPipeline.tree, getNodeDataObject], (modularPipelinesTree, nodes) => {
  if (!modularPipelinesTree) {
    return {};
  }
  for (const modularPipelineID in modularPipelinesTree) {
    modularPipelinesTree[modularPipelineID].data = {
      ...nodes[modularPipelineID]
    };
    for (const child of modularPipelinesTree[modularPipelineID].children) {
      child.data = {
        ...nodes[child.id]
      };
    }
  }
  return modularPipelinesTree;
});

/**
 * Returns formatted nodes grouped by type
 */
const getGroupedNodes = exports.getGroupedNodes = (0, _reselect.createSelector)([getNodeData], nodes => nodes.reduce(function (obj, item) {
  const key = item.type;
  if (!obj.hasOwnProperty(key)) {
    obj[key] = [];
  }
  obj[key].push(item);
  return obj;
}, {}));

/**
 * Temporarily create a new SVG container in the DOM, write a node to it,
 * measure its width with getBBox, then delete the container and store the value
 */
const getNodeTextWidth = exports.getNodeTextWidth = (0, _reselect.createSelector)([_pipeline.getPipelineNodeIDs, getNodeLabel], (nodeIDs, nodeLabel) => {
  const nodeTextWidth = {};
  const svg = (0, _d3Selection.select)(document.body).append('svg').attr('class', 'kedro pipeline-node');
  svg.selectAll('text').data(nodeIDs).enter().append('text').text(nodeID => nodeLabel[nodeID]).each(function (nodeID) {
    const width = this.getBBox ? this.getBBox().width : 0;
    nodeTextWidth[nodeID] = width;
  });
  svg.remove();
  return nodeTextWidth;
});

/**
 * Get the top/bottom and left/right padding for a node
 * @param {Boolean} showLabels Whether labels are visible
 * @param {Boolean} isTask Whether the node is a task type (vs data/params)
 */
const getPadding = (showLabels, nodeType) => {
  if (showLabels) {
    switch (nodeType) {
      case 'modularPipeline':
        return {
          x: 30,
          y: 22
        };
      case 'task':
        return {
          x: 16,
          y: 10
        };
      default:
        return {
          x: 20,
          y: 10
        };
    }
  }
  switch (nodeType) {
    case 'modularPipeline':
      return {
        x: 25,
        y: 25
      };
    case 'task':
      return {
        x: 14,
        y: 14
      };
    default:
      return {
        x: 16,
        y: 16
      };
  }
};

/**
 * Calculate node width/height and icon/text positioning
 */
exports.getPadding = getPadding;
const getNodeSize = exports.getNodeSize = (0, _reselect.createSelector)([_pipeline.getPipelineNodeIDs, getNodeTextWidth, getTextLabels, getNodeType], (nodeIDs, nodeTextWidth, textLabels, nodeType) => {
  return (0, _utils.arrayToObject)(nodeIDs, nodeID => {
    const iconSize = textLabels ? 24 : 28;
    const padding = getPadding(textLabels, nodeType[nodeID]);
    const textWidth = textLabels ? nodeTextWidth[nodeID] : 0;
    const textGap = textLabels ? 6 : 0;
    const innerWidth = iconSize + textWidth + textGap;
    return {
      showText: textLabels,
      width: innerWidth + padding.x * 2,
      height: iconSize + padding.y * 2,
      textOffset: (innerWidth - textWidth) / 2 - 1,
      iconOffset: -innerWidth / 2,
      iconSize
    };
  });
});

/**
 * Returns only visible nodes as an array, but without any extra properties
 * that are unnecessary for the chart layout calculation
 */
const getVisibleNodes = exports.getVisibleNodes = (0, _reselect.createSelector)([_disabled.getVisibleNodeIDs, getNodeLabel, getNodeType, getNodeDatasetType, getNodeFullName, getNodeSize, getNodeLayer, _ranks.getNodeRank], (nodeIDs, nodeLabel, nodeType, nodeDatasetType, nodeFullName, nodeSize, nodeLayer, nodeRank) => nodeIDs.map(id => ({
  id,
  name: nodeLabel[id],
  fullName: nodeFullName[id],
  icon: (0, _shortType.default)(nodeDatasetType[id], nodeType[id]),
  type: nodeType[id],
  layer: nodeLayer[id],
  rank: nodeRank[id],
  ...nodeSize[id]
})));

/**
 * Returns a map of task nodeIDs to graph nodes that have parameter nodes as their source
 */

const getNodesWithInputParams = exports.getNodesWithInputParams = (0, _reselect.createSelector)([getGraphNodes, getNodeName, getEdgeIDs, getNodeType, getEdgeSources, getEdgeTargets], (nodes, nodeName, edgeIDs, nodeType, edgeSources, edgeTargets) => {
  const nodesList = {};
  for (const edgeID of edgeIDs) {
    const source = edgeSources[edgeID];
    const target = edgeTargets[edgeID];
    if (nodeType[source] === 'parameters' && nodeType[target] === 'task') {
      if (!nodesList[target]) {
        nodesList[target] = [];
      }
      nodesList[target].push(nodeName[source]);
    }
  }
  return nodesList;
});

/**
 * Returns a list of dataset nodes that are input and output nodes of the modular pipeline under focus mode
 */
const getInputOutputNodesForFocusedModularPipeline = exports.getInputOutputNodesForFocusedModularPipeline = (0, _reselect.createSelector)([state => {
  var _state$visible$modula;
  return (_state$visible$modula = state.visible.modularPipelineFocusMode) === null || _state$visible$modula === void 0 ? void 0 : _state$visible$modula.id;
}, getGraphNodes, getModularPipelinesTree], (focusedModularPipelineID, graphNodes, modularPipelinesTree) => {
  const focusedModularPipeline = focusedModularPipelineID ? modularPipelinesTree[focusedModularPipelineID] : null;
  const nodeIDs = focusedModularPipeline ? [...focusedModularPipeline.inputs, ...focusedModularPipeline.outputs] : [];
  const result = nodeIDs.reduce((result, nodeID) => {
    result[nodeID] = graphNodes[nodeID];
    return result;
  }, {});
  return result;
});